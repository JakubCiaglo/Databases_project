{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Projekt z Baz Danych – Raport Końcowy\"\n",
        "format:\n",
        "  html:\n",
        "    toc: true\n",
        "    number-sections: true\n",
        "    code-fold: true\n",
        "    code-summary: \"Rozwiń kod\"\n",
        "    theme:\n",
        "      light: flatly\n",
        "      dark: darkly\n",
        "page-layout: full\n",
        "---\n",
        "\n",
        "# Autorzy\n",
        "\n",
        "- Jakub Ciągło  \n",
        "- Mateusz Ćwiek  \n",
        "- Marek Dworaczyk  \n",
        "- Rafał Głodek\n",
        "\n",
        "# Importy"
      ],
      "id": "164f2f2e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import mysql.connector\n",
        "import random\n",
        "import math\n",
        "from datetime import date, datetime, timedelta, time\n",
        "from dateutil.relativedelta import relativedelta\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "from faker import Faker"
      ],
      "id": "5011194d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Skryptowe wypełnienie bazy\n",
        "## Połączenie z bazą danych i wyczyszczenie jej"
      ],
      "id": "8970ae07"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "con = mysql.connector.connect(\n",
        "    host = \"giniewicz.it\",\n",
        "    user = \"team13\",\n",
        "    password = \"te@mlie\",\n",
        "    database = \"team13\"\n",
        ")\n",
        "\n",
        "if(con):\n",
        "    print(\"Połączenie udane\")\n",
        "else:\n",
        "    print(\"Połączenie nieudane\")\n",
        "\n",
        "cursor = con.cursor()\n",
        "\n",
        "cursor.execute('SET FOREIGN_KEY_CHECKS = 0')\n",
        "\n",
        "tables = [\n",
        "    'employee_assignments',\n",
        "    'feedback',\n",
        "    'transactions',\n",
        "    'trip_participants',\n",
        "    'incidents',\n",
        "    'costs',\n",
        "    'trips',\n",
        "    'trip_types',\n",
        "    'destinations',\n",
        "    'launch_stations',\n",
        "    'spacecraft',\n",
        "    'rockets',\n",
        "    'emergency_contacts',\n",
        "    'clients',\n",
        "    'employees'\n",
        "]\n",
        "\n",
        "for table in tables:\n",
        "    cursor.execute(f'TRUNCATE TABLE {table}')\n",
        "\n",
        "cursor.execute('SET FOREIGN_KEY_CHECKS = 1')\n",
        "\n",
        "con.commit()\n",
        "cursor.close()\n",
        "print('Wyczyszczono wszystkie tabele.')"
      ],
      "id": "9d49328a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Wyznaczenie parametrów"
      ],
      "id": "f31a328e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "n_employees = 200\n",
        "clients_per_emp = 3 \n",
        "n_clients = n_employees * clients_per_emp\n",
        "min_salary_pln = 14666.00 \n",
        "avg_salary_pln = 30045.11\n",
        "\n",
        "current_date = datetime.now() + relativedelta(years=1000)\n",
        "start_of_business = current_date - relativedelta(years=5)\n",
        "\n",
        "print(start_of_business)"
      ],
      "id": "c992991b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Generowanie pracowników"
      ],
      "id": "90159efe"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fake = Faker(\"pl_PL\")\n",
        "rng = np.random.default_rng()\n",
        "\n",
        "POSITIONS = [\n",
        "    (\"Pilot statku\", 0.07), (\"Inżynier systemów\", 0.12),\n",
        "    (\"Technik pokładowy\", 0.15), (\"Kontroler lotów\", 0.1),\n",
        "    (\"Astrogator\", 0.05), (\"Specjalista ds. bezpieczeństwa\", 0.05),\n",
        "    (\"Inspektor jakości\", 0.06), (\"Specjalista HR\", 0.04),\n",
        "    (\"Analityk danych\", 0.06), (\"Marketing kosmiczny\", 0.04),\n",
        "    (\"Finanse / Księgowość\", 0.06), (\"Lekarz pokładowy\", 0.05),\n",
        "    (\"Kucharz orbitalny\", 0.03), (\"Administrator IT\", 0.05),\n",
        "    (\"Mechanik rakietowy\", 0.07)\n",
        "]\n",
        "titles, weights = zip(*POSITIONS)\n",
        "\n",
        "def random_salary():\n",
        "    raw = rng.lognormal(mean=math.log(avg_salary_pln), sigma=0.25)\n",
        "    return round(max(raw, min_salary_pln), 2)\n",
        "\n",
        "def hire_and_term():\n",
        "    # Obliczamy różnicę w dniach między start_of_business a current_date - 6 miesięcy\n",
        "    end_hire_period = current_date - relativedelta(months=6)\n",
        "    total_days = (end_hire_period - start_of_business).days\n",
        "    \n",
        "    # Losujemy liczbę dni i dodajemy do start_of_business, aby uzyskać datę zatrudnienia\n",
        "    random_days = random.randint(0, total_days)\n",
        "    hire = start_of_business + timedelta(days=random_days)\n",
        "    \n",
        "    # ~15% pracowników już nie pracuje\n",
        "    if random.random() < 0.15:\n",
        "        # Data zakończenia pracy musi być co najmniej 3 miesiące po zatrudnieniu\n",
        "        min_term_date = hire + relativedelta(months=3)\n",
        "        term_days = (current_date - min_term_date).days\n",
        "        \n",
        "        if term_days > 0:\n",
        "            random_term_days = random.randint(0, term_days)\n",
        "            term = min_term_date + timedelta(days=random_term_days)\n",
        "        else:\n",
        "            term = None  # Jeśli nie ma możliwej daty zakończenia\n",
        "    else:\n",
        "        term = None  # Nadal pracuje\n",
        "    \n",
        "    return hire, term\n",
        "\n",
        "emp_rows, used_emails_emp = [], set()\n",
        "print(f'Generowanie danych dla {n_employees} pracowników...')\n",
        "for i in range(n_employees):\n",
        "    first, last = fake.first_name(), fake.last_name()\n",
        "    position = random.choices(titles, weights)[0]\n",
        "    salary = random_salary()\n",
        "    hire, term = hire_and_term()\n",
        "\n",
        "    base_email = f'{first}.{last}'.lower().replace(' ', '').replace(\"'\", '')\n",
        "    email = base_email + '@spaceu.com'\n",
        "    suffix = 1\n",
        "    while email in used_emails_emp:\n",
        "        email = f'{base_email}{suffix}@spaceu.com'\n",
        "        suffix += 1\n",
        "    used_emails_emp.add(email)\n",
        "\n",
        "    phone = fake.phone_number()\n",
        "\n",
        "    if random.random() < 0.02:\n",
        "        email = None\n",
        "        phone = None\n",
        "\n",
        "    emp_rows.append({\n",
        "        'first_name': first,\n",
        "        'last_name': last,\n",
        "        'position': position,\n",
        "        'salary': salary,\n",
        "        'hire_date': hire,\n",
        "        'termination_date': term,\n",
        "        'email': email,\n",
        "        'phone': phone\n",
        "    })\n",
        "\n",
        "df_emp = pd.DataFrame(emp_rows)\n",
        "print(f\"Wygenerowano {len(df_emp)} rekordów dla pracowników.\")\n",
        "\n",
        "df_emp"
      ],
      "id": "58149ba4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Generowanie klientów"
      ],
      "id": "0cfde5ec"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "cli_rows, used_emails_cli = [], set()\n",
        "domains = ['gmail.com', 'outlook.com', 'yahoo.com', 'protonmail.com']\n",
        "\n",
        "print(f\"\\nGenerowanie danych dla {n_clients} klientów...\")\n",
        "for i in range(n_clients):\n",
        "    first, last = fake.first_name(), fake.last_name()\n",
        "    base = f\"{first}.{last}\".lower().replace(\" \", \"\").replace(\"'\", \"\")\n",
        "    domain = random.choice(domains)\n",
        "    email_candidate = f\"{base}@{domain}\"\n",
        "    suffix = 1\n",
        "    while email_candidate in used_emails_cli or email_candidate in used_emails_emp:\n",
        "        email_candidate = f\"{base}{suffix}@{domain}\"\n",
        "        suffix += 1\n",
        "\n",
        "    phone = fake.phone_number()\n",
        "\n",
        "    if random.random() < 0.02:\n",
        "        email_candidate = None\n",
        "        phone = None\n",
        "\n",
        "    birth_date = fake.date_of_birth(minimum_age=18, maximum_age=75)\n",
        "    shifted_birth_date = birth_date.replace(year=birth_date.year + 1000)\n",
        "\n",
        "    cli_rows.append({\n",
        "        \"first_name\": first,\n",
        "        \"last_name\": last,\n",
        "        \"date_of_birth\": shifted_birth_date,\n",
        "        \"email\": email_candidate,\n",
        "        \"phone\": phone\n",
        "    })\n",
        "\n",
        "df_cli = pd.DataFrame(cli_rows)\n",
        "print(f\"Wygenerowano {len(df_cli)} rekordów dla klientów.\")\n",
        "df_cli"
      ],
      "id": "94e2a23c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Zapis pracowników i klientów do bazy (test)"
      ],
      "id": "b4cf0857"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "if con and con.is_connected():\n",
        "    cursor = con.cursor()\n",
        "    print(\"\\nPołączono z bazą danych. Rozpoczynanie wstawiania danych...\")\n",
        "\n",
        "    sql_insert_employee = \"\"\"\n",
        "    INSERT INTO employees (first_name, last_name, position, salary, hire_date, termination_date, email, phone)\n",
        "    VALUES (%(first_name)s, %(last_name)s, %(position)s, %(salary)s, %(hire_date)s, %(termination_date)s, %(email)s, %(phone)s)\n",
        "    \"\"\"\n",
        "    employee_records_to_insert = df_emp.to_dict(orient='records')\n",
        "    \n",
        "    try:\n",
        "        cursor.executemany(sql_insert_employee, employee_records_to_insert)\n",
        "        con.commit()\n",
        "        print(f\"{cursor.rowcount} rekordów wstawiono/zaktualizowano w tabeli employees.\")\n",
        "    except mysql.connector.Error as err:\n",
        "        print(f\"Błąd podczas wstawiania do employees: {err}\")\n",
        "        con.rollback()\n",
        "\n",
        "    sql_insert_client = \"\"\"\n",
        "    INSERT INTO clients (first_name, last_name, date_of_birth, email, phone)\n",
        "    VALUES (%(first_name)s, %(last_name)s, %(date_of_birth)s, %(email)s, %(phone)s)\n",
        "    \"\"\"\n",
        "    client_records_to_insert = df_cli.to_dict(orient='records')\n",
        "\n",
        "    try:\n",
        "        cursor.executemany(sql_insert_client, client_records_to_insert)\n",
        "        con.commit()\n",
        "        print(f\"{cursor.rowcount} rekordów wstawiono/zaktualizowano w tabeli clients.\")\n",
        "    except mysql.connector.Error as err:\n",
        "        print(f\"Błąd podczas wstawiania do clients: {err}\")\n",
        "        con.rollback()\n",
        "\n",
        "    # Pokaż, ile w sumie w bazie (używając mysql.connector)\n",
        "    try:\n",
        "        cursor.execute(\"SELECT COUNT(*) FROM employees\")\n",
        "        total_emp = cursor.fetchone()[0]\n",
        "        print(f\"Łącznie w tabeli employees: {total_emp}\")\n",
        "\n",
        "        cursor.execute(\"SELECT COUNT(*) FROM clients\")\n",
        "        total_cli = cursor.fetchone()[0]\n",
        "        print(f\"Łącznie w tabeli clients: {total_cli}\")\n",
        "    except mysql.connector.Error as err:\n",
        "        print(f\"Błąd podczas odczytu liczby rekordów: {err}\")\n",
        "\n",
        "    print(\"Zakończono operacje na bazie danych dla tego bloku.\")\n",
        "else:\n",
        "    print(\"Błąd: Połączenie z bazą danych ('con') nie jest aktywne lub nie zostało poprawnie zainicjowane.\")"
      ],
      "id": "faa273a6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Wprowadzenie pozostałych tabel\n",
        "## Wygenerowanie statków kosmicznych i rakiet"
      ],
      "id": "6d7645c0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def random_date(start_date=start_of_business):\n",
        "    end_date = start_date + timedelta(days=2*365)\n",
        "    delta_days = (end_date - start_date).days\n",
        "    return start_date + timedelta(days=random.randint(0, delta_days))\n",
        "\n",
        "MANUFACTURERS = [\"NASA\", \"SpaceX\", \"Blue Origin\", \"ULA\", \"Roscosmos\", \"Arianespace\"]\n",
        "\n",
        "def generate_spacecraft_entries(n=30):\n",
        "    prefixes = ['Nova', 'Luna', 'Astra', 'Zenith', 'Hyperion', 'Celestia', 'Pulsar', 'Eclipse', 'Titan', 'Vortex']\n",
        "    suffixes = ['X', 'One', 'Prime', '7', 'NX', 'Infinity', 'Core', 'Ultra', 'VX', 'Edge']\n",
        "    statuses = ['ACTIVE', 'RETIRED', 'MAINT']\n",
        "\n",
        "    # Zestaw, w którym będziemy trzymać już użyte nazwy\n",
        "    used_names = set()\n",
        "    spacecraft = []\n",
        "\n",
        "    # Maksymalna liczba możliwych unikalnych kombinacji to len(prefixes)*len(suffixes)=100\n",
        "    if n > len(prefixes) * len(suffixes):\n",
        "        raise ValueError(f\"Nie da się wygenerować {n} unikalnych nazw (maksymalnie {len(prefixes)*len(suffixes)}).\")\n",
        "\n",
        "    for _ in range(n):\n",
        "        # Generujemy nazwę, aż będzie unikalna\n",
        "        while True:\n",
        "            name = f\"{random.choice(prefixes)}-{random.choice(suffixes)}\"\n",
        "            if name not in used_names:\n",
        "                used_names.add(name)\n",
        "                break\n",
        "\n",
        "        manufacturer = random.choice(MANUFACTURERS)\n",
        "        capacity = random.randint(40, 60)\n",
        "        status = random.choices(statuses, weights=[0.8, 0.1, 0.1])[0]\n",
        "        start_date = random_date()\n",
        "        end_date = None\n",
        "\n",
        "        if status == 'RETIRED':\n",
        "            min_end_date = start_date + timedelta(days=365)\n",
        "            max_end_date = min_end_date + timedelta(days=3*365)\n",
        "            end_date = min_end_date + timedelta(days=random.randint(0, (max_end_date - min_end_date).days))\n",
        "\n",
        "        spacecraft.append((capacity, name, manufacturer, start_date, end_date, status))\n",
        "\n",
        "    return spacecraft\n",
        "\n",
        "\n",
        "def generate_rocket_entries(n=30):\n",
        "    prefixes = ['Falcon', 'Vega', 'Atlas', 'Delta', 'Zephyr', 'Aegis', 'Cyclone', 'Talon', 'Nova', 'Strato']\n",
        "    suffixes = ['IX', 'V', 'Max', 'Pro', 'Ultra', '1000', 'Eon', 'Zero', 'R', 'Edge']\n",
        "    statuses = ['ACTIVE', 'RETIRED', 'MAINT']\n",
        "\n",
        "    used_names = set()\n",
        "    rockets = []\n",
        "\n",
        "    # Maksymalna liczba możliwych unikalnych kombinacji to znów 10*10 = 100\n",
        "    if n > len(prefixes) * len(suffixes):\n",
        "        raise ValueError(f\"Nie da się wygenerować {n} unikalnych nazw rakiet (maksymalnie {len(prefixes)*len(suffixes)}).\")\n",
        "\n",
        "    for _ in range(n):\n",
        "        while True:\n",
        "            name = f\"{random.choice(prefixes)}-{random.choice(suffixes)}\"\n",
        "            if name not in used_names:\n",
        "                used_names.add(name)\n",
        "                break\n",
        "\n",
        "        manufacturer = random.choice(MANUFACTURERS)\n",
        "        status = random.choices(statuses, weights=[0.8, 0.1, 0.1])[0]\n",
        "        rockets.append((name, manufacturer, status))\n",
        "\n",
        "    return rockets\n"
      ],
      "id": "cdbbdf79",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Stałe do oferty (nazwy itp.) i wprowadzenie ich do bazy"
      ],
      "id": "023fe8f4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "launch_stations = [\n",
        "    (\"Kennedy Space Center\",      \"USA\", \"Cape Canaveral\", \"ACTIVE\"),\n",
        "    (\"Baikonur Cosmodrome\",       \"Kazakhstan\", \"Baikonur\", \"ACTIVE\"),\n",
        "    (\"Guiana Space Centre\",       \"France\", \"Kourou\", \"ACTIVE\"),\n",
        "    (\"Wenchang\",                  \"China\", \"Wenchang\", \"ACTIVE\"),\n",
        "    (\"Space-U Pad Baltic\",        \"Poland\", \"Ustka\", \"PLANNED\")\n",
        "]\n",
        "\n",
        "rockets = generate_rocket_entries()\n",
        "\n",
        "spacecraft = generate_spacecraft_entries()\n",
        "\n",
        "destinations = [\n",
        "    (\"Merkury\", \"Najmniejsza i najbliższa Słońcu planeta Układu Słonecznego\", 0.38, \"HIGH\"),\n",
        "    (\"Wenus\", \"Druga planeta od Słońca, o gęstej atmosferze i ekstremalnym cieple\", 0.90, \"HIGH\"),\n",
        "    (\"Mars\", \"Czwarta planeta od Słońca, znana jako Czerwona Planeta\", 0.38, \"MEDIUM\"),\n",
        "    (\"Jowisz\", \"Największa planeta w Układzie Słonecznym, gazowy olbrzym\", 0.16, \"CRITICAL\"),\n",
        "    (\"Saturn\", \"Gazowy olbrzym znany z wyraźnych pierścieni\", 0.92, \"MEDIUM\")\n",
        "]\n",
        "\n",
        "trip_types = [\n",
        "    (\"Misja Orbitalna\",              \"Orbita i obserwacja powierzchni planety\",           14, 6_000_000),\n",
        "    (\"Zejście Atmosferyczne\",        \"Zejście w atmosferę i analiza składu chemicznego\",  21, 7_500_000),\n",
        "    (\"Ekspedycja Księżycowa\",        \"Eksploracja naturalnych satelitów\",                 20, 9_000_000),\n",
        "    (\"Obóz Badawczy w Kosmosie\",     \"Eksperymenty z pokładu bazy orbitalnej\",          45,16_000_000),\n",
        "    (\"Przelot przez Pasy Radiacyjne\",\"Przelot przez pasy radiacyjne i pomiary\",           40,10_000_000),\n",
        "    (\"Obserwacja Pierścieni\",        \"Obserwacja struktur pierścieni planetarnych\",     20,12_000_000),\n",
        "    (\"Eksplorator Magnetosfery\",     \"Pomiary pola magnetycznego i zorze\",                30, 7_000_000),\n",
        "    (\"Manewr Grawitacyjny\",          \"Test manewrów grawitacyjnych przy dużych obiektach\",10, 5_500_000)\n",
        "]\n",
        "\n",
        "\n",
        "def insert_many(q, rows):\n",
        "    cursor.executemany(q, rows)\n",
        "    con.commit()\n",
        "\n",
        "insert_many(\n",
        "    \"INSERT INTO launch_stations (name, country, city, status) VALUES (%s, %s, %s, %s)\",\n",
        "    [(n, c, ci, s) for n, c, ci, s in launch_stations]\n",
        ")\n",
        "\n",
        "insert_many(\n",
        "    \"INSERT INTO rockets (name, manufacturer, status) VALUES (%s, %s, %s)\",\n",
        "    [(n, m, s) for n, m, s in rockets]\n",
        ")\n",
        "\n",
        "insert_many(\n",
        "    \"INSERT INTO spacecraft (capacity_passengers, name, manufacturer, service_start_date, service_end_date, status) \"\n",
        "    \"VALUES (%s, %s, %s, %s, %s, %s)\",\n",
        "    [(cap, n, m, start, end, s) for cap, n, m, start, end, s in spacecraft]\n",
        ")\n",
        "\n",
        "insert_many(\n",
        "    \"INSERT INTO destinations (name, description, avg_gravity, hazard_level) VALUES (%s, %s, %s, %s)\",\n",
        "    [(n, d, g, h) for n, d, g, h in destinations]\n",
        ")\n",
        "\n",
        "insert_many(\n",
        "    \"INSERT INTO trip_types (name, description, typical_duration_days, base_price) VALUES (%s, %s, %s, %s)\",\n",
        "    [(n, d, dur, price) for n, d, dur, price in trip_types]\n",
        ")\n",
        "\n",
        "print(\"► Załadowano słownikowe tabele.\")"
      ],
      "id": "79e27245",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Generowanie trips (50 lotów - można zmienić)"
      ],
      "id": "553d700c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "cursor.execute('SELECT trip_type_id, typical_duration_days FROM trip_types')\n",
        "trip_types = cursor.fetchall()\n",
        "trip_type_durations = dict(trip_types)\n",
        "\n",
        "cursor.execute('SELECT destination_id FROM destinations')\n",
        "destinations = [row[0] for row in cursor.fetchall()]\n",
        "\n",
        "cursor.execute(\"SELECT launch_station_id FROM launch_stations WHERE status = 'ACTIVE'\")\n",
        "launch_stations = [row[0] for row in cursor.fetchall()]\n",
        "\n",
        "cursor.execute(\"SELECT spacecraft_id FROM spacecraft WHERE status = 'ACTIVE'\")\n",
        "spacecrafts = [row[0] for row in cursor.fetchall()]\n",
        "\n",
        "cursor.execute(\"SELECT rocket_id FROM rockets WHERE status = 'ACTIVE'\")\n",
        "rockets = [row[0] for row in cursor.fetchall()]\n",
        "\n",
        "statuses = ['completed', 'in progress', 'planned']\n",
        "\n",
        "# 2) Inicjalizujemy \"kalendarze\" dla zasobów\n",
        "spacecraft_schedule     = { sc: [] for sc in spacecrafts }\n",
        "rocket_schedule         = { rk: [] for rk in rockets }\n",
        "records_to_insert = []\n",
        "\n",
        "# Funkcja sprawdzająca kolizję przedziałów\n",
        "def is_overlapping(new_start, new_end, existing_intervals):\n",
        "    new_end = new_end or datetime.max\n",
        "    for ex_start, ex_end in existing_intervals:\n",
        "        ex_end = ex_end or datetime.max\n",
        "        if not (new_end < ex_start or ex_end < new_start):\n",
        "            return True\n",
        "    return False\n",
        "\n",
        "# 3) Generujemy 50 wypraw\n",
        "\n",
        "for _ in range(50):\n",
        "    trip_type_id = random.choice(list(trip_type_durations.keys()))\n",
        "    duration = trip_type_durations[trip_type_id]\n",
        "\n",
        "    destination_id = random.choice(destinations)\n",
        "    launch_station_id = random.choice(launch_stations)\n",
        "\n",
        "    status = random.choices(statuses, weights=[0.7, 0.1, 0.2])[0]\n",
        "\n",
        "    if status == 'completed':\n",
        "        # Używamy start_of_business jako punktu odniesienia\n",
        "        base_date = start_of_business + timedelta(days=random.randint(0, 5*365 - duration))\n",
        "        departure = datetime(\n",
        "            base_date.year, base_date.month, base_date.day,\n",
        "            random.randint(0,23), random.randint(0,59), random.randint(0,59)\n",
        "        )\n",
        "        return_date = base_date + timedelta(days=duration)\n",
        "        return_dt = datetime(\n",
        "            return_date.year, return_date.month, return_date.day,\n",
        "            random.randint(0,23), random.randint(0,59), random.randint(0,59)\n",
        "        )\n",
        "\n",
        "    elif status == 'in progress':\n",
        "        # Używamy current_date zamiast datetime.now()\n",
        "        days_back = random.randint(1, duration)\n",
        "        rand_dt = current_date - timedelta(days=days_back)\n",
        "        departure = datetime(\n",
        "            rand_dt.year, rand_dt.month, rand_dt.day,\n",
        "            random.randint(0,23), random.randint(0,59), random.randint(0,59)\n",
        "        )\n",
        "        return_dt = None\n",
        "\n",
        "    else:  # status == 'planned'\n",
        "        days_forward = random.randint(1, 365)\n",
        "        future_dt = current_date + timedelta(days=days_forward)\n",
        "        departure = datetime(\n",
        "            future_dt.year, future_dt.month, future_dt.day,\n",
        "            random.randint(0,23), random.randint(0,59), random.randint(0,59)\n",
        "        )\n",
        "        return_dt = None\n",
        "\n",
        "    new_start = departure\n",
        "    new_end = return_dt if return_dt is not None else datetime.max.replace(year=current_date.year + 100)\n",
        "\n",
        "    chosen_spacecraft = None\n",
        "    chosen_rocket = None\n",
        "\n",
        "    # 4) Wybór zasobów bez kolizji\n",
        "    for attempt in range(100):\n",
        "        sc = random.choice(spacecrafts)\n",
        "        if is_overlapping(new_start, new_end, spacecraft_schedule[sc]):\n",
        "            continue\n",
        "\n",
        "        rk = random.choice(rockets)\n",
        "        if is_overlapping(new_start, new_end, rocket_schedule[rk]):\n",
        "            continue\n",
        "\n",
        "        chosen_spacecraft = sc\n",
        "        chosen_rocket = rk\n",
        "        break\n",
        "\n",
        "    if chosen_spacecraft is None:\n",
        "        raise RuntimeError(\n",
        "            \"Nie znaleziono wolnego statku + rakiety. \"\n",
        "            \"Zmniejsz liczbę lotów lub zasobów.\"\n",
        "        )\n",
        "\n",
        "    # 5) Rejestrujemy zajęcie zasobów\n",
        "    spacecraft_schedule[chosen_spacecraft].append((new_start, new_end))\n",
        "    rocket_schedule[chosen_rocket].append((new_start, new_end))\n",
        "\n",
        "    # 6) Dodajemy wiersz do listy INSERT\n",
        "    records_to_insert.append((\n",
        "        trip_type_id,\n",
        "        destination_id,\n",
        "        launch_station_id,\n",
        "        chosen_spacecraft,\n",
        "        chosen_rocket,\n",
        "        departure,\n",
        "        return_dt,\n",
        "        status\n",
        "    ))\n",
        "\n",
        "# 7) Wstawiamy wygenerowane trasy do tabeli trips\n",
        "cursor.executemany(\n",
        "    '''\n",
        "    INSERT INTO trips (\n",
        "        trip_type_id, destination_id, launch_station_id,\n",
        "        spacecraft_id, rocket_id, departure_datetime,\n",
        "        return_datetime, status\n",
        "    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)\n",
        "    ''',\n",
        "    records_to_insert\n",
        ")\n",
        "con.commit()"
      ],
      "id": "7bf75c70",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Generowanie pracowników do lotu (jest 35 na lot- mozna zmienić)"
      ],
      "id": "9b3ad3fd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "excluded_positions = [\n",
        "    'Finanse / Księgowość',\n",
        "    'Analityk danych',\n",
        "    'Marketing kosmiczny',\n",
        "    'Administrator IT',\n",
        "    'Specjalista HR'\n",
        "]\n",
        "\n",
        "# Pobierz pracowników z dozwolonych stanowisk\n",
        "cursor.execute(\n",
        "    '''\n",
        "    SELECT employee_id, position\n",
        "    FROM employees\n",
        "    WHERE position NOT IN (%s)\n",
        "    ''' % ','.join(['%s'] * len(excluded_positions)),\n",
        "    excluded_positions\n",
        ")\n",
        "crew_data = cursor.fetchall()  # lista (employee_id, position)\n",
        "\n",
        "from collections import defaultdict\n",
        "position_map = defaultdict(list)\n",
        "for emp_id, pos in crew_data:\n",
        "    position_map[pos].append(emp_id)\n",
        "\n",
        "allowed_positions = list(position_map.keys())\n",
        "\n",
        "# Pobierz trip_id oraz daty\n",
        "cursor.execute('SELECT trip_id, departure_datetime, return_datetime FROM trips')\n",
        "trip_info = cursor.fetchall()\n",
        "\n",
        "# Harmonogram pracowników\n",
        "employee_schedule = defaultdict(list)\n",
        "assignments = []\n",
        "\n",
        "for trip_id, departure, return_dt in trip_info:\n",
        "    selected_employees = set()\n",
        "    trip_assignment = []\n",
        "    new_start = departure\n",
        "    new_end = return_dt or datetime.max\n",
        "\n",
        "    # Po jednej osobie z każdego stanowiska\n",
        "    for position, emp_list in position_map.items():\n",
        "        random.shuffle(emp_list)\n",
        "        for emp_id in emp_list:\n",
        "            if not is_overlapping(new_start, new_end, employee_schedule[emp_id]):\n",
        "                selected_employees.add(emp_id)\n",
        "                employee_schedule[emp_id].append((new_start, new_end))\n",
        "                trip_assignment.append((trip_id, emp_id))\n",
        "                break\n",
        "\n",
        "    # Losowe osoby do uzupełnienia do 35\n",
        "    remaining_pool = [\n",
        "        (emp_id, pos)\n",
        "        for pos, emp_ids in position_map.items()\n",
        "        for emp_id in emp_ids\n",
        "        if emp_id not in selected_employees and not is_overlapping(new_start, new_end, employee_schedule[emp_id])\n",
        "    ]\n",
        "    additional_needed = 35 - len(trip_assignment)\n",
        "    if additional_needed > 0:\n",
        "        random.shuffle(remaining_pool)\n",
        "        additional_crew = remaining_pool[:additional_needed]\n",
        "        for emp_id, pos in additional_crew:\n",
        "            selected_employees.add(emp_id)\n",
        "            employee_schedule[emp_id].append((new_start, new_end))\n",
        "            trip_assignment.append((trip_id, emp_id))\n",
        "\n",
        "    assignments.extend(trip_assignment)\n",
        "\n",
        "cursor.executemany(\n",
        "    '''\n",
        "    INSERT INTO employee_assignments (trip_id, employee_id)\n",
        "    VALUES (%s, %s)\n",
        "    ''',\n",
        "    assignments\n",
        ")\n",
        "con.commit()\n"
      ],
      "id": "3e6890a5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Generowanie pasażerów dla lotów\n"
      ],
      "id": "5a0bd426"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Pobierz klientów\n",
        "cursor.execute('SELECT client_id FROM clients')\n",
        "client_ids = [row[0] for row in cursor.fetchall()]\n",
        "\n",
        "# Pobierz loty wraz z przypisanymi statkami, statusem i datami\n",
        "cursor.execute('SELECT trip_id, spacecraft_id, status, departure_datetime, return_datetime FROM trips')\n",
        "trips_data = cursor.fetchall()  # lista (trip_id, spacecraft_id, status, departure_datetime, return_datetime)\n",
        "\n",
        "# Pobierz pojemności statków\n",
        "cursor.execute('SELECT spacecraft_id, capacity_passengers FROM spacecraft')\n",
        "capacity_map = dict(cursor.fetchall())  # dict: spacecraft_id -> capacity\n",
        "\n",
        "# Stwórz strukturę: trip_id -> (capacity, status, departure, return)\n",
        "trip_info = {\n",
        "    trip_id: (capacity_map[spacecraft_id], status, departure, return_dt)\n",
        "    for trip_id, spacecraft_id, status, departure, return_dt in trips_data\n",
        "}\n",
        "\n",
        "# Przygotuj dane do INSERT\n",
        "trip_participants = defaultdict(list)  # trip_id -> list of (client_id, seat_number)\n",
        "client_trip_assignments = defaultdict(list)  # client_id -> list of (departure, return)\n",
        "\n",
        "# 1. Zapełnij w pełni loty 'completed' i 'in progress'\n",
        "filled_trips = [tid for tid, (_, status, _, _) in trip_info.items() if status in ('completed', 'in progress')]\n",
        "available_clients = client_ids.copy()\n",
        "random.shuffle(available_clients)\n",
        "\n",
        "for trip_id in filled_trips:\n",
        "    capacity, _, departure, return_dt = trip_info[trip_id]\n",
        "    assigned = 0\n",
        "    for client_id in available_clients:\n",
        "        if assigned >= capacity:\n",
        "            break\n",
        "        if not is_overlapping(departure, return_dt, client_trip_assignments[client_id]):\n",
        "            seat_number = len(trip_participants[trip_id]) + 1\n",
        "            trip_participants[trip_id].append((client_id, seat_number))\n",
        "            client_trip_assignments[client_id].append((departure, return_dt))\n",
        "            assigned += 1\n",
        "\n",
        "# 2. Upewnij się, że każdy klient jest przypisany do co najmniej jednego lotu\n",
        "all_trip_ids = list(trip_info.keys())\n",
        "random.shuffle(all_trip_ids)\n",
        "\n",
        "for client_id in client_ids:\n",
        "    if not client_trip_assignments[client_id]:\n",
        "        for trip_id in all_trip_ids:\n",
        "            capacity, _, departure, return_dt = trip_info[trip_id]\n",
        "            if len(trip_participants[trip_id]) >= capacity:\n",
        "                continue\n",
        "            if not is_overlapping(departure, return_dt, client_trip_assignments[client_id]):\n",
        "                seat_number = len(trip_participants[trip_id]) + 1\n",
        "                trip_participants[trip_id].append((client_id, seat_number))\n",
        "                client_trip_assignments[client_id].append((departure, return_dt))\n",
        "                break\n",
        "\n",
        "# 3. Uzupełnij loty 'planned' (częściowo)\n",
        "for trip_id, (capacity, status, departure, return_dt) in trip_info.items():\n",
        "    if status != 'planned':\n",
        "        continue\n",
        "    remaining_seats = capacity - len(trip_participants[trip_id])\n",
        "    if remaining_seats <= 0:\n",
        "        continue\n",
        "    random.shuffle(client_ids)\n",
        "    for client_id in client_ids:\n",
        "        if remaining_seats == 0:\n",
        "            break\n",
        "        if not is_overlapping(departure, return_dt, client_trip_assignments[client_id]):\n",
        "            seat_number = len(trip_participants[trip_id]) + 1\n",
        "            trip_participants[trip_id].append((client_id, seat_number))\n",
        "            client_trip_assignments[client_id].append((departure, return_dt))\n",
        "            remaining_seats -= 1\n",
        "\n",
        "# Przygotuj dane do INSERT\n",
        "records_to_insert = [\n",
        "    (trip_id, client_id, seat_number)\n",
        "    for trip_id, participants in trip_participants.items()\n",
        "    for client_id, seat_number in participants\n",
        "]\n",
        "\n",
        "cursor.executemany(\n",
        "    '''\n",
        "    INSERT INTO trip_participants (trip_id, client_id, seat_number)\n",
        "    VALUES (%s, %s, %s)\n",
        "    ''',\n",
        "    records_to_insert\n",
        ")\n",
        "con.commit()\n"
      ],
      "id": "99d61a7d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Emergency contacts"
      ],
      "id": "6f8f520d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "cursor.execute('SELECT client_id, date_of_birth FROM clients')\n",
        "clients = cursor.fetchall()\n",
        "\n",
        "# relacje rozdzielone według płci\n",
        "# relacje rozdzielone według płci\n",
        "male_relationships = ['ojciec', 'brat', 'mąż', 'partner', 'przyjaciel', 'syn']\n",
        "female_relationships = ['matka', 'siostra', 'żona', 'partnerka', 'przyjaciółka', 'córka']\n",
        "domains = ['gmail.com', 'outlook.com', 'yahoo.com', 'protonmail.com']\n",
        "\n",
        "records_to_insert = []\n",
        "used_emails_contacts = set()\n",
        "\n",
        "for client_id, dob in clients:\n",
        "    birth_year = dob.year\n",
        "    if birth_year < 2965:\n",
        "        available_relationships = [r for r in male_relationships + female_relationships if r not in ['matka', 'ojciec']]\n",
        "    elif birth_year > 2990:\n",
        "        available_relationships = [r for r in male_relationships + female_relationships if r not in ['syn', 'córka']]\n",
        "    else:\n",
        "        available_relationships = male_relationships + female_relationships\n",
        "\n",
        "    used_relationships = set()\n",
        "    for _ in range(2):\n",
        "        while True:\n",
        "            gender = random.choice(['male', 'female'])\n",
        "            first_name = fake.first_name_male() if gender == 'male' else fake.first_name_female()\n",
        "            last_name = fake.last_name()\n",
        "\n",
        "            base_email = f\"{first_name}.{last_name}\".lower().replace(\" \", \"\").replace(\"'\", \"\")\n",
        "            domain = random.choice(domains)\n",
        "            email = f\"{base_email}@{domain}\"\n",
        "            suffix = 1\n",
        "            while email in used_emails_contacts:\n",
        "                email = f\"{base_email}{suffix}@{domain}\"\n",
        "                suffix += 1\n",
        "            used_emails_contacts.add(email)\n",
        "\n",
        "            phone = fake.phone_number()\n",
        "\n",
        "            if random.random() < 0.02:\n",
        "                email = None\n",
        "                phone = None\n",
        "\n",
        "            rel_pool = male_relationships if gender == 'male' else female_relationships\n",
        "            rel_choices = [r for r in rel_pool if r in available_relationships and r not in used_relationships]\n",
        "\n",
        "            if rel_choices:\n",
        "                relationship = random.choice(rel_choices)\n",
        "                used_relationships.add(relationship)\n",
        "                break\n",
        "\n",
        "        records_to_insert.append((\n",
        "            client_id,\n",
        "            first_name,\n",
        "            last_name,\n",
        "            relationship,\n",
        "            email,\n",
        "            phone\n",
        "        ))\n",
        "\n",
        "cursor.executemany(\n",
        "    '''\n",
        "    INSERT INTO emergency_contacts (\n",
        "        client_id, first_name, last_name,\n",
        "        relationship, email, phone\n",
        "    ) VALUES (%s, %s, %s, %s, %s, %s)\n",
        "    ''',\n",
        "    records_to_insert\n",
        ")\n",
        "\n",
        "\n",
        "con.commit()\n"
      ],
      "id": "1c4a37db",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Generowanie transakcji (transactions) dla uczestników lotów"
      ],
      "id": "724d2a7c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 1. Pobierz dane o uczestnikach lotów wraz z informacjami o ich wyprawie i cenie bazowej\n",
        "cursor.execute(\"\"\"\n",
        "    SELECT \n",
        "        tp.trip_id, \n",
        "        tp.client_id, \n",
        "        t.departure_datetime, \n",
        "        tt.base_price\n",
        "    FROM trip_participants tp\n",
        "    JOIN trips t ON tp.trip_id = t.trip_id\n",
        "    JOIN trip_types tt ON t.trip_type_id = tt.trip_type_id\n",
        "\"\"\")\n",
        "participants_data = cursor.fetchall()  # lista wierszy: (trip_id, client_id, departure_datetime, base_price)\n",
        "\n",
        "# 2. Definicja metod płatności i statusów transakcji\n",
        "payment_methods = ['credit_card', 'wire_transfer', 'paypal', 'crypto']\n",
        "# statusy: tylko przyszłe loty mogą być \"pending\", przeszłe będą zawsze \"completed\"\n",
        "future_statuses = ['completed', 'pending']\n",
        "\n",
        "records_to_insert = []\n",
        "now = datetime.now() + relativedelta(years=1000)\n",
        "start_dt = datetime.combine(start_of_business, time(0, 0, 0))\n",
        "\n",
        "for trip_id, client_id, departure_dt, base_price in participants_data:\n",
        "    # 3. Oblicz maksymalną liczbę dni, o które można cofnąć transakcję\n",
        "    if departure_dt > now:\n",
        "        days_diff = (departure_dt - start_dt).days\n",
        "        max_advance_days = min(180, days_diff) if days_diff > 0 else 1\n",
        "        days_before_departure = random.randint(1, max_advance_days)\n",
        "    else:\n",
        "        days_diff = (now - start_dt).days\n",
        "        max_advance_days = min(180, days_diff) if days_diff > 0 else 1\n",
        "        days_before_departure = random.randint(1, max_advance_days)\n",
        "\n",
        "    # 4. Generujemy wstępną datę transakcji\n",
        "    transaction_date = departure_dt - timedelta(\n",
        "        days=days_before_departure,\n",
        "        hours=random.randint(0, 23),\n",
        "        minutes=random.randint(0, 59),\n",
        "        seconds=random.randint(0, 59)\n",
        "    )\n",
        "\n",
        "    # 5. Gdyby przypadkiem wyszła przed startem działalności → losujemy między start_dt a teraz\n",
        "    if transaction_date < start_dt:\n",
        "        earliest = start_dt\n",
        "        latest = now\n",
        "        diff_seconds = int((latest - earliest).total_seconds())\n",
        "        random_offset = random.randint(0, diff_seconds)\n",
        "        transaction_date = earliest + timedelta(seconds=random_offset)\n",
        "\n",
        "    # 6. Kwota transakcji (bazowa ±5%)\n",
        "    variation_pct = random.uniform(-0.05, 0.05)\n",
        "    amount = round(float(base_price) * (1 + variation_pct), 2)\n",
        "\n",
        "    # 7. Wybór metody płatności oraz statusu\n",
        "    payment_method = random.choice(payment_methods)\n",
        "    if departure_dt > now:\n",
        "        # lot jeszcze w przyszłości → możliwe 'completed' lub 'pending'\n",
        "        status = random.choices(future_statuses, weights=[0.7, 0.3])[0]\n",
        "    else:\n",
        "        # lot w przeszłości → zawsze 'completed'\n",
        "        status = 'completed'\n",
        "\n",
        "    records_to_insert.append((trip_id, client_id, transaction_date, amount, payment_method, status))\n",
        "\n",
        "# 8. Wstawianie do tabeli transactions\n",
        "cursor.executemany(\n",
        "    \"\"\"\n",
        "    INSERT INTO transactions (\n",
        "        trip_id, client_id, transaction_date, amount, payment_method, status\n",
        "    ) VALUES (%s, %s, %s, %s, %s, %s)\n",
        "    \"\"\",\n",
        "    records_to_insert\n",
        ")\n",
        "con.commit()"
      ],
      "id": "1c37d7ae",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Generowanie opinii dla zakończonych lotów"
      ],
      "id": "0e9e3132"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# --- 1. Pobierz zakończonych uczestników ---\n",
        "cursor.execute(\"\"\"\n",
        "    SELECT \n",
        "        tp.trip_id, \n",
        "        tp.client_id, \n",
        "        t.return_datetime\n",
        "    FROM trip_participants tp\n",
        "    JOIN trips t ON tp.trip_id = t.trip_id\n",
        "    WHERE t.status = 'completed'\n",
        "      AND t.return_datetime IS NOT NULL\n",
        "\"\"\")\n",
        "completed_participants = cursor.fetchall()  # lista: (trip_id, client_id, return_datetime)\n",
        "\n",
        "# --- 2. Pobierz trip_id, w których były incydenty ---\n",
        "cursor.execute(\"SELECT DISTINCT trip_id FROM incidents\")\n",
        "trips_with_incidents = {row[0] for row in cursor.fetchall()}\n",
        "\n",
        "# --- 3. Listy komentarzy ---\n",
        "negative_comments = [\n",
        "    \"Lot był bardzo niewygodny, a obsługa niezbyt pomocna.\",\n",
        "    \"Paliwo się skończyło, a procedury awaryjne były chaotyczne.\",\n",
        "    \"Posiłki były zimne i bez smaku. Ogólnie rozczarowanie.\",\n",
        "    \"Sprzęt naukowy na pokładzie nie działał, stracony czas.\",\n",
        "    \"Osoby odpowiedzialne za bezpieczeństwo były niekompetentne.\",\n",
        "    \"Kabina zbyt mała, bardzo ciasno i duszno.\",\n",
        "    \"Trudności z łącznością, nie mogłem porozmawiać z rodziną.\"\n",
        "]\n",
        "neutral_comments = [\n",
        "    \"Lot odbył się zgodnie z planem, ale niczym szczególnym się nie wyróżniał.\",\n",
        "    \"Stacja na orbicie spełniła minimalne oczekiwania, trudno coś więcej dodać.\",\n",
        "    \"Czas spędzony w stanie nieważkości był interesujący, ale krótki.\",\n",
        "    \"Obsługa była w miarę profesjonalna, choć bez entuzjazmu.\",\n",
        "    \"Warunki codziennego pobytu w module były przeciętne.\"\n",
        "]\n",
        "positive_comments = [\n",
        "    \"Przelot przebiegł bez zarzutu, widoki zapierające dech w piersiach.\",\n",
        "    \"Personel bardzo pomocny, poczułem się w pełni bezpiecznie.\",\n",
        "    \"Eksperymenty naukowe w module okazały się fascynujące.\",\n",
        "    \"Kabina komfortowa, z dużą przestrzenią i świetnym widokiem.\",\n",
        "    \"Powrót na Ziemię był płynny, lądowanie perfekcyjne.\",\n",
        "    \"Panel widokowy statku doskonale zaprojektowany dla fotografów.\",\n",
        "    \"Program edukacyjny na pokładzie dostarczył wiele wiedzy.\"\n",
        "]\n",
        "\n",
        "# --- 4. Generowanie i wstawianie opinii ---\n",
        "feedback_rows = []\n",
        "now = datetime.now()\n",
        "\n",
        "for trip_id, client_id, return_dt in completed_participants:\n",
        "    # ok. 70% zostawia opinię\n",
        "    if random.random() > 0.7:\n",
        "        continue\n",
        "\n",
        "    # jeśli lot miał incydent — oceny z 1–3 (z przewagą niskich)\n",
        "    if trip_id in trips_with_incidents:\n",
        "        rating = random.choices([1,2,3], weights=[0.5,0.3,0.2])[0]\n",
        "    else:\n",
        "        # inaczej z 3–5 (z przewagą wysokich)\n",
        "        rating = random.choices([3,4,5], weights=[0.1,0.3,0.6])[0]\n",
        "\n",
        "    # dobór komentarza do oceny\n",
        "    if rating <= 2:\n",
        "        comments = random.choice(negative_comments)\n",
        "    elif rating == 3:\n",
        "        comments = random.choice(neutral_comments)\n",
        "    else:\n",
        "        comments = random.choice(positive_comments)\n",
        "\n",
        "    # data przesłania: między 1 a 30 dni po return_dt, ale nie później niż teraz\n",
        "    raw_date = return_dt + timedelta(\n",
        "        days=random.randint(1,30),\n",
        "        hours=random.randint(0,23),\n",
        "        minutes=random.randint(0,59),\n",
        "        seconds=random.randint(0,59)\n",
        "    )\n",
        "    submitted_at = raw_date if raw_date < now else now - timedelta(\n",
        "        days=random.randint(0,3),\n",
        "        hours=random.randint(0,23),\n",
        "        minutes=random.randint(0,59),\n",
        "        seconds=random.randint(0,59)\n",
        "    )\n",
        "\n",
        "    feedback_rows.append((trip_id, client_id, rating, comments, submitted_at))\n",
        "\n",
        "cursor.executemany(\n",
        "    \"\"\"\n",
        "    INSERT INTO feedback (\n",
        "        trip_id, client_id, rating, comments, submitted_at\n",
        "    ) VALUES (%s, %s, %s, %s, %s)\n",
        "    \"\"\",\n",
        "    feedback_rows\n",
        ")\n",
        "con.commit()"
      ],
      "id": "50708881",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Generowanie incydentów"
      ],
      "id": "c1ce31a8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# 1. Pobierz dane o lotach (trip_id, departure, return) oraz przypisanych pracownikach i klientach\n",
        "cursor.execute(\"\"\"\n",
        "    SELECT trip_id, departure_datetime, return_datetime\n",
        "    FROM trips\n",
        "    WHERE status IN ('completed', 'in progress')\n",
        "\"\"\")\n",
        "trips_data = cursor.fetchall()  # lista: (trip_id, departure_datetime, return_datetime)\n",
        "\n",
        "# Przypisani pracownicy:\n",
        "cursor.execute(\"SELECT trip_id, employee_id FROM employee_assignments\")\n",
        "assignments = cursor.fetchall()  # lista: (trip_id, employee_id)\n",
        "trip_to_employees = {}\n",
        "for trip_id, emp_id in assignments:\n",
        "    trip_to_employees.setdefault(trip_id, []).append(emp_id)\n",
        "\n",
        "# Uczestnicy (klienci):\n",
        "cursor.execute(\"SELECT trip_id, client_id FROM trip_participants\")\n",
        "parts = cursor.fetchall()  # lista: (trip_id, client_id)\n",
        "trip_to_clients = {}\n",
        "for trip_id, client_id in parts:\n",
        "    trip_to_clients.setdefault(trip_id, []).append(client_id)\n",
        "\n",
        "# 2. Przygotuj szablony incydentów, gdzie każdy wpis zawiera:\n",
        "#    - description,\n",
        "#    - category odpowiadające opisowi,\n",
        "#    - requires_client (True/False),\n",
        "#    - lista możliwych poziomów severity\n",
        "incident_templates = [\n",
        "    {\n",
        "        \"description\": \"Problemy z ciśnieniem w module medycznym, szybka reakcja lekarza.\",\n",
        "        \"category\": \"medical\",\n",
        "        \"requires_client\": True,\n",
        "        \"possible_severities\": [\"medium\", \"high\"]\n",
        "    },\n",
        "    {\n",
        "        \"description\": \"Awaria systemu orientacji – konieczne ręczne sterowanie przez pilota.\",\n",
        "        \"category\": \"navigation\",\n",
        "        \"requires_client\": False,\n",
        "        \"possible_severities\": [\"medium\", \"high\", \"critical\"]\n",
        "    },\n",
        "    {\n",
        "        \"description\": \"Utrata łączności z Ziemią na krótki okres, przywrócono po 15 minutach.\",\n",
        "        \"category\": \"communication\",\n",
        "        \"requires_client\": False,\n",
        "        \"possible_severities\": [\"low\", \"medium\"]\n",
        "    },\n",
        "    {\n",
        "        \"description\": \"Niewielki pożar w komorze silnikowej, ugaszono systemami automatycznymi.\",\n",
        "        \"category\": \"equipment\",\n",
        "        \"requires_client\": False,\n",
        "        \"possible_severities\": [\"high\", \"critical\"]\n",
        "    },\n",
        "    {\n",
        "        \"description\": \"Podejrzenie choroby lokomocyjnej u jednego z pasażerów, interwencja medyczna.\",\n",
        "        \"category\": \"medical\",\n",
        "        \"requires_client\": True,\n",
        "        \"possible_severities\": [\"low\", \"medium\"]\n",
        "    },\n",
        "    {\n",
        "        \"description\": \"Nieprawidłowy odczyt czujnika paliwa – wymagana weryfikacja inżynierska.\",\n",
        "        \"category\": \"equipment\",\n",
        "        \"requires_client\": False,\n",
        "        \"possible_severities\": [\"medium\", \"high\"]\n",
        "    },\n",
        "    {\n",
        "        \"description\": \"Zauważono podejrzany obiekt kosmiczny, wykonano dodatkową analizę.\",\n",
        "        \"category\": \"navigation\",\n",
        "        \"requires_client\": False,\n",
        "        \"possible_severities\": [\"low\", \"medium\"]\n",
        "    },\n",
        "    {\n",
        "        \"description\": \"Krótki alarm związany z poziomem tlenu, natychmiastowe sprawdzenie.\",\n",
        "        \"category\": \"security\",\n",
        "        \"requires_client\": False,\n",
        "        \"possible_severities\": [\"medium\", \"high\"]\n",
        "    }\n",
        "]\n",
        "\n",
        "# 3. Wygeneruj incydenty\n",
        "incident_rows = []\n",
        "now = datetime.now()\n",
        "\n",
        "for trip_id, departure_dt, return_dt in trips_data:\n",
        "    # Losujemy 0-2 incydenty na lot\n",
        "    n_incidents = random.randint(0, 2)\n",
        "    for _ in range(n_incidents):\n",
        "        # Wybierz szablon\n",
        "        template = random.choice(incident_templates)\n",
        "        description = template[\"description\"]\n",
        "        category = template[\"category\"]\n",
        "        requires_client = template[\"requires_client\"]\n",
        "        severity = random.choice(template[\"possible_severities\"])\n",
        "\n",
        "        # Wybierz moment wystąpienia incydentu:\n",
        "        # – Jeśli lot zakończony (return_dt nie jest None), to losowo między departure_dt a return_dt\n",
        "        # – Jeśli 'in progress', to losowo między departure_dt a teraz\n",
        "        start_time = departure_dt\n",
        "        end_time = return_dt if return_dt is not None else now\n",
        "        if end_time <= start_time:\n",
        "            incident_time = start_time + timedelta(hours=1)\n",
        "        else:\n",
        "            total_seconds = int((end_time - start_time).total_seconds())\n",
        "            offset = random.randint(1, total_seconds - 1)\n",
        "            incident_time = start_time + timedelta(seconds=offset)\n",
        "\n",
        "        # Wybierz zgłaszającego pracownika (jeśli przypisanych brak, ustaw None)\n",
        "        employees_for_trip = trip_to_employees.get(trip_id, [])\n",
        "        reported_by = random.choice(employees_for_trip) if employees_for_trip else None\n",
        "\n",
        "        # Jeśli w szablonie requires_client=True, losuj klienta z trip_to_clients\n",
        "        involved_client = None\n",
        "        if requires_client:\n",
        "            clients_for_trip = trip_to_clients.get(trip_id, [])\n",
        "            if clients_for_trip:\n",
        "                involved_client = random.choice(clients_for_trip)\n",
        "\n",
        "        incident_rows.append((\n",
        "            trip_id,\n",
        "            incident_time,\n",
        "            reported_by,\n",
        "            involved_client,\n",
        "            category,\n",
        "            description,\n",
        "            severity\n",
        "        ))\n",
        "\n",
        "# 4. Wstawianie do tabeli incidents\n",
        "cursor.executemany(\n",
        "    \"\"\"\n",
        "    INSERT INTO incidents (\n",
        "        trip_id, datetime_occurred, reported_by_employee,\n",
        "        involved_client_id, category, description, severity\n",
        "    ) VALUES (%s, %s, %s, %s, %s, %s, %s)\n",
        "    \"\"\",\n",
        "    incident_rows\n",
        ")\n",
        "con.commit()"
      ],
      "id": "91db2e3d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Generowanie kosztów dla każdej wyprawy"
      ],
      "id": "be168264"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "cursor.execute(\"\"\"\n",
        "    SELECT trip_id, tt.base_price\n",
        "    FROM trips t\n",
        "    JOIN trip_types tt ON t.trip_type_id = tt.trip_type_id\n",
        "\"\"\")\n",
        "trip_base_prices = cursor.fetchall()  # lista: (trip_id, base_price)\n",
        "\n",
        "# 2. Podstawowe kategorie kosztów\n",
        "base_cost_templates = [\n",
        "    {\"description\": \"paliwo\",                    \"min_pct\": 0.15, \"max_pct\": 0.25},\n",
        "    {\"description\": \"obsługa załogi\",             \"min_pct\": 0.10, \"max_pct\": 0.18},\n",
        "    {\"description\": \"zapasy żywności\",            \"min_pct\": 0.05, \"max_pct\": 0.10},\n",
        "    {\"description\": \"utrzymanie statku\",          \"min_pct\": 0.08, \"max_pct\": 0.12},\n",
        "    {\"description\": \"ubezpieczenie\",              \"min_pct\": 0.03, \"max_pct\": 0.06},\n",
        "    {\"description\": \"telekomunikacja\",            \"min_pct\": 0.02, \"max_pct\": 0.04},\n",
        "    {\"description\": \"amortyzacja sprzętu\",         \"min_pct\": 0.05, \"max_pct\": 0.10},\n",
        "    {\"description\": \"usługi medyczne\",            \"min_pct\": 0.02, \"max_pct\": 0.05},\n",
        "    {\"description\": \"utrzymanie stacji startowej\", \"min_pct\": 0.04, \"max_pct\": 0.08},\n",
        "    {\"description\": \"serwis i naprawy\",           \"min_pct\": 0.06, \"max_pct\": 0.10}\n",
        "]\n",
        "\n",
        "# 3. Definiujemy dodatkowe koszty zależne od incydentów:\n",
        "#    - jeśli wystąpił incydent \"equipment\", to dodajemy koszt naprawy sprzętu\n",
        "#    - \"medical\" → dodatkowe usługi medyczne\n",
        "#    - \"security\" → koszt operacji bezpieczeństwa\n",
        "#    - \"navigation\" → koszty korekty kursu\n",
        "#    - \"communication\" → koszty przywrócenia łączności\n",
        "incident_cost_map = {\n",
        "    \"equipment\":    {\"description\": \"dodatkowa naprawa sprzętu (z incydentu)\", \"min_pct\": 0.05, \"max_pct\": 0.10},\n",
        "    \"medical\":      {\"description\": \"dodatkowe usługi medyczne (z incydentu)\", \"min_pct\": 0.03, \"max_pct\": 0.07},\n",
        "    \"security\":     {\"description\": \"operacje bezpieczeństwa (z incydentu)\", \"min_pct\": 0.005, \"max_pct\": 0.01},\n",
        "    \"navigation\":   {\"description\": \"korekta kursu (z incydentu)\", \"min_pct\": 0.005, \"max_pct\": 0.1},\n",
        "    \"communication\":{\"description\": \"przywrócenie łączności (z incydentu)\", \"min_pct\": 0.02, \"max_pct\": 0.06},\n",
        "}\n",
        "\n",
        "# 4. Przygotowanie danych o incydentach: dla każdego trip_id zbieramy listę kategorii incydentu\n",
        "cursor.execute(\"SELECT trip_id, category FROM incidents\")\n",
        "incidents_data = cursor.fetchall()  # lista: (trip_id, category)\n",
        "trip_to_incidents = {}\n",
        "for trip_id, category in incidents_data:\n",
        "    trip_to_incidents.setdefault(trip_id, set()).add(category)\n",
        "\n",
        "# 5. Generuj wiersze do costs\n",
        "cost_rows = []\n",
        "\n",
        "for trip_id, base_price in trip_base_prices:\n",
        "    bp = float(base_price)  # rzutujemy na float\n",
        "\n",
        "    # 5a. Wstawiamy wszystkie podstawowe kategorie kosztów\n",
        "    for tpl in base_cost_templates:\n",
        "        pct = random.uniform(tpl[\"min_pct\"], tpl[\"max_pct\"])\n",
        "        cost_amount = round(bp * pct, 2)\n",
        "        cost_rows.append((trip_id, tpl[\"description\"], cost_amount))\n",
        "\n",
        "    # 5b. Jeśli dla tego trip_id były jakieś incydenty, dodajemy odpowiednie pozycje kosztowe\n",
        "    categories_for_trip = trip_to_incidents.get(trip_id, [])\n",
        "    for cat in categories_for_trip:\n",
        "        if cat in incident_cost_map:\n",
        "            tpl_inc = incident_cost_map[cat]\n",
        "            pct_inc = random.uniform(tpl_inc[\"min_pct\"], tpl_inc[\"max_pct\"])\n",
        "            amount_inc = round(bp * pct_inc, 2)\n",
        "            cost_rows.append((trip_id, tpl_inc[\"description\"], amount_inc))\n",
        "\n",
        "# 6. Wstawianie danych do tabeli costs\n",
        "cursor.executemany(\n",
        "    \"\"\"\n",
        "    INSERT INTO costs (\n",
        "        trip_id, description, cost_amount\n",
        "    ) VALUES (%s, %s, %s)\n",
        "    \"\"\",\n",
        "    cost_rows\n",
        ")\n",
        "con.commit()"
      ],
      "id": "1217c3b7",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\matio\\AppData\\Roaming\\Python\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}