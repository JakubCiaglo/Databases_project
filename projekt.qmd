---
title: "Projekt z Baz Danych – Raport Końcowy"
format:
  html:
    toc: true
    number-sections: true
    code-fold: true
    code-summary: "Rozwiń kod"
    theme:
      light: flatly
      dark: darkly
page-layout: full
---

## Autorzy

- Jakub Ciągło  
- Mateusz Ćwiek  
- Marek Dworaczyk  
- Rafał Głodek

## Importy
```{python}
import mysql.connector
import random
import math
from datetime import date, datetime, timedelta
from dateutil.relativedelta import relativedelta
import numpy as np
import pandas as pd
from faker import Faker
```

## Połączenie z bazą danych i wyczyszczenie jej

```{python}

con = mysql.connector.connect(
    host = "giniewicz.it",
    user = "team13",
    password = "te@mlie",
    database = "team13"
)

if(con):
    print("Połączenie udane")
else:
    print("Połączenie nieudane")

cursor = con.cursor()

cursor.execute('SET FOREIGN_KEY_CHECKS = 0')

tables = [
    'employee_assignments',
    'feedback',
    'transactions',
    'trip_participants',
    'incidents',
    'costs',
    'trips',
    'trip_types',
    'destinations',
    'launch_stations',
    'spacecraft',
    'rockets',
    'emergency_contacts',
    'clients',
    'employees'
]

for table in tables:
    cursor.execute(f'TRUNCATE TABLE {table}')

cursor.execute('SET FOREIGN_KEY_CHECKS = 1')

con.commit()
cursor.close()
print('Wyczyszczono wszystkie tabele.')
```

## Wyznaczenie parametrów

```{python}
n_employees = 200
clients_per_emp = 3 
n_clients = n_employees * clients_per_emp
min_salary_pln = 4666.00 
avg_salary_pln = 9045.11

current_date = date.today()
start_of_business = current_date - relativedelta(years=5)

print(start_of_business)

```

## Generowanie pracowników

```{python}

fake = Faker("pl_PL")
rng = np.random.default_rng()

POSITIONS = [
    ("Pilot statku", 0.07), ("Inżynier systemów", 0.12),
    ("Technik pokładowy", 0.15), ("Kontroler lotów", 0.1),
    ("Astrogator", 0.05), ("Specjalista ds. bezpieczeństwa", 0.05),
    ("Inspektor jakości", 0.06), ("Specjalista HR", 0.04),
    ("Analityk danych", 0.06), ("Marketing kosmiczny", 0.04),
    ("Finanse / księgowość", 0.06), ("Lekarz pokładowy", 0.05),
    ("Kucharz orbitalny", 0.03), ("Administrator IT", 0.05),
    ("Mechanik rakietowy", 0.07)
]
titles, weights = zip(*POSITIONS)

def random_salary():
    raw = rng.lognormal(mean=math.log(avg_salary_pln), sigma=0.25)
    return round(max(raw, min_salary_pln), 2)

def hire_and_term():
    # Używamy current_date dla spójności
    hire = fake.date_between_dates(start_of_business, current_date - relativedelta(months=6))
    if random.random() < 0.15:  # ~15 % już nie pracuje
        term = fake.date_between_dates(hire + relativedelta(months=3), current_date)
    else:
        term = None
    return hire, term

emp_rows, used_emails_emp = [], set()
print(f"Generowanie danych dla {n_employees} pracowników...")
for i in range(n_employees):
    first, last = fake.first_name(), fake.last_name()
    position = random.choices(titles, weights)[0]
    salary = random_salary()
    hire, term = hire_and_term()

    base_email = f"{first}.{last}".lower().replace(" ", "").replace("'", "") # Dodatkowe czyszczenie
    email = base_email + "@spaceu.com"
    suffix = 1
    while email in used_emails_emp:
        email = f"{base_email}{suffix}@spaceu.com"
        suffix += 1
    used_emails_emp.add(email)

    emp_rows.append({
        "first_name": first,
        "last_name": last,
        "position": position,
        "salary": salary,
        "hire_date": hire,
        "termination_date": term,
        "email": email,
        "phone": fake.phone_number()
    })

df_emp = pd.DataFrame(emp_rows)
print(f"Wygenerowano {len(df_emp)} rekordów dla pracowników.")

df_emp
```

## Generowanie klientów

```{python}

cli_rows, used_emails_cli = [], set()

print(f"\nGenerowanie danych dla {n_clients} klientów...")
for i in range(n_clients):
    first, last = fake.first_name(), fake.last_name()
    client_email = None
    base = f"{first}.{last}".lower().replace(" ", "").replace("'", "")
    email_candidate = base + "@gmail.com"
    suffix = 1
    while email_candidate in used_emails_cli or email_candidate in used_emails_emp:
        email_candidate = f"{base}{suffix}@gmail.com"
        suffix += 1
    client_email = email_candidate
    used_emails_cli.add(client_email)

    cli_rows.append({
        "first_name": first,
        "last_name": last,
        "date_of_birth": fake.date_of_birth(minimum_age=18, maximum_age=75),
        "email": client_email,
        "phone": fake.phone_number()
    })

df_cli = pd.DataFrame(cli_rows)
print(f"Wygenerowano {len(df_cli)} rekordów dla klientów.")
df_cli
```

## Zapis danych do bazy

```{python}
if con and con.is_connected():
    cursor = con.cursor()
    print("\nPołączono z bazą danych. Rozpoczynanie wstawiania danych...")

    sql_insert_employee = """
    INSERT INTO employees (first_name, last_name, position, salary, hire_date, termination_date, email, phone)
    VALUES (%(first_name)s, %(last_name)s, %(position)s, %(salary)s, %(hire_date)s, %(termination_date)s, %(email)s, %(phone)s)
    """
    employee_records_to_insert = df_emp.to_dict(orient='records')
    
    try:
        cursor.executemany(sql_insert_employee, employee_records_to_insert)
        con.commit()
        print(f"{cursor.rowcount} rekordów wstawiono/zaktualizowano w tabeli employees.")
    except mysql.connector.Error as err:
        print(f"Błąd podczas wstawiania do employees: {err}")
        con.rollback()

    sql_insert_client = """
    INSERT INTO clients (first_name, last_name, date_of_birth, email, phone)
    VALUES (%(first_name)s, %(last_name)s, %(date_of_birth)s, %(email)s, %(phone)s)
    """
    client_records_to_insert = df_cli.to_dict(orient='records')

    try:
        cursor.executemany(sql_insert_client, client_records_to_insert)
        con.commit()
        print(f"{cursor.rowcount} rekordów wstawiono/zaktualizowano w tabeli clients.")
    except mysql.connector.Error as err:
        print(f"Błąd podczas wstawiania do clients: {err}")
        con.rollback()

    # Pokaż, ile w sumie w bazie (używając mysql.connector)
    try:
        cursor.execute("SELECT COUNT(*) FROM employees")
        total_emp = cursor.fetchone()[0]
        print(f"Łącznie w tabeli employees: {total_emp}")

        cursor.execute("SELECT COUNT(*) FROM clients")
        total_cli = cursor.fetchone()[0]
        print(f"Łącznie w tabeli clients: {total_cli}")
    except mysql.connector.Error as err:
        print(f"Błąd podczas odczytu liczby rekordów: {err}")

    print("Zakończono operacje na bazie danych dla tego bloku.")
else:
    print("Błąd: Połączenie z bazą danych ('con') nie jest aktywne lub nie zostało poprawnie zainicjowane.")
```

## Wygenerowanie statków kosmicznych
```{python}

def random_date(start_date=start_of_business):
    end_date = start_date + timedelta(days=2*365)
    delta_days = (end_date - start_date).days
    return start_date + timedelta(days=random.randint(0, delta_days))


def generate_spacecraft_entries():
    names = [
        "Starship-Aurora", "Starliner-Vista", "Dragon-TourerXL", "Orion-Cruiser",
        "CosmoLiner-5", "Nebula-Swift", "Phoenix-Xplorer", "Voyager-Next"
    ]
    manufacturers = [
        "Space-U", "Boeing / Space-U", "Space-U / SpaceX", "NASA / Lockheed",
        "ESA / Airbus", "Blue Origin", "JAXA", "Roscosmos"
    ]
    capacities = [random.randint(40, 60) for _ in range(len(names))]
    statuses = ["ACTIVE", "RETIRED", "MAINT"]

    spacecraft = []
    for name, manufacturer, capacity in zip(names, manufacturers, capacities):
        status = random.choice(statuses)
        start_date = random_date()
        end_date = None
        if status == "RETIRED":
            min_end_date = start_date + timedelta(days=365)
            max_end_date = min_end_date + timedelta(days=3*365)
            end_date = min_end_date + timedelta(days=random.randint(0, (max_end_date - min_end_date).days))
        spacecraft.append((capacity, name, manufacturer, start_date, end_date, status))
    
    return spacecraft

```


## Stałe do oferty (nazwy itp.) i wprowadzenie ich do bazy

```{python}
launch_stations = [
    ("Kennedy Space Center",      "USA", "Cape Canaveral", "ACTIVE"),
    ("Baikonur Cosmodrome",       "Kazakhstan", "Baikonur", "ACTIVE"),
    ("Guiana Space Centre",       "France", "Kourou", "ACTIVE"),
    ("Wenchang",                  "China", "Wenchang", "ACTIVE"),
    ("Space-U Pad Baltic",        "Poland", "Ustka", "PLANNED")
]

rockets = [
    ("Falcon Heavy-U",     "Space-U / SpaceX",         "ACTIVE"),
    ("New Glenn-U",        "Blue Origin / Space-U",    "MAINT"),
    ("Starship-U",         "Space-U",                  "ACTIVE"),
    ("Vulcan Explorer",    "ULA / Space-U",            "ACTIVE"),
    ("Ariane 7",           "ESA / Arianespace",        "RETIRED"),
    ("Phoenix Booster",    "JAXA",                     "ACTIVE"),
    ("Sirius 9",           "Roscosmos",                "RETIRED"),
    ("CosmoLift X",        "Space-U",                  "MAINT"),
    ("Thunderbird-1",      "ISRO",                     "ACTIVE"),
    ("Atlas Prime",        "NASA / Space-U",           "PROTOTYPE")
]

spacecraft = generate_spacecraft_entries()

destinations = [
    ("Merkury", "Najmniejsza i najbliższa Słońcu planeta Układu Słonecznego", 0.38, "HIGH"),
    ("Wenus", "Druga planeta od Słońca, o gęstej atmosferze i ekstremalnym cieple", 0.90, "HIGH"),
    ("Mars", "Czwarta planeta od Słońca, znana jako Czerwona Planeta", 0.38, "MEDIUM"),
    ("Jowisz", "Największa planeta w Układzie Słonecznym, gazowy olbrzym", 0.16, "CRITICAL"),
    ("Saturn", "Gazowy olbrzym znany z wyraźnych pierścieni", 0.92, "MEDIUM")
]

trip_types = [
    ("Misja Orbitalna",              "14 dni, orbita i obserwacja powierzchni planety",           14, 6_000_000),
    ("Zejście Atmosferyczne",        "21 dni, zejście w atmosferę i analiza składu chemicznego",  21, 7_500_000),
    ("Ekspedycja Księżycowa",        "60 dni, eksploracja naturalnych satelitów",                 60, 9_000_000),
    ("Obóz Badawczy w Kosmosie",     "180 dni, eksperymenty z pokładu bazy orbitalnej",          180,16_000_000),
    ("Przelot przez Pasy Radiacyjne","90 dni, przelot przez pasy radiacyjne i pomiary",           90,10_000_000),
    ("Obserwacja Pierścieni",        "120 dni, obserwacja struktur pierścieni planetarnych",     120,12_000_000),
    ("Eksplorator Magnetosfery",     "30 dni, pomiary pola magnetycznego i zorze",                30, 7_000_000),
    ("Manewr Grawitacyjny",          "10 dni, test manewrów grawitacyjnych przy dużych obiektach",10, 5_500_000)
]


def insert_many(q, rows):
    cursor.executemany(q, rows)
    con.commit()

insert_many(
    "INSERT INTO launch_stations (name, country, city, status) VALUES (%s, %s, %s, %s)",
    [(n, c, ci, s) for n, c, ci, s in launch_stations]
)

insert_many(
    "INSERT INTO rockets (name, manufacturer, status) VALUES (%s, %s, %s)",
    [(n, m, s) for n, m, s in rockets]
)

insert_many(
    "INSERT INTO spacecraft (capacity_passengers, name, manufacturer, service_start_date, service_end_date, status) "
    "VALUES (%s, %s, %s, %s, %s, %s)",
    [(cap, n, m, start, end, s) for cap, n, m, start, end, s in spacecraft]
)

insert_many(
    "INSERT INTO destinations (name, description, avg_gravity, hazard_level) VALUES (%s, %s, %s, %s)",
    [(n, d, g, h) for n, d, g, h in destinations]
)

insert_many(
    "INSERT INTO trip_types (name, description, typical_duration_days, base_price) VALUES (%s, %s, %s, %s)",
    [(n, d, dur, price) for n, d, dur, price in trip_types]
)

print("► Załadowano słownikowe tabele.")
```

## Generowanie trips (50 lotów - można zmienić)

```{python}

cursor.execute('SELECT trip_type_id, typical_duration_days FROM trip_types')
trip_types = cursor.fetchall()
trip_type_durations = dict(trip_types)

cursor.execute('SELECT destination_id FROM destinations')
destinations = [row[0] for row in cursor.fetchall()]

cursor.execute('SELECT launch_station_id FROM launch_stations')
launch_stations = [row[0] for row in cursor.fetchall()]

cursor.execute('SELECT spacecraft_id FROM spacecraft')
spacecrafts = [row[0] for row in cursor.fetchall()]

cursor.execute("SELECT rocket_id FROM rockets WHERE status = 'ACTIVE'")
rockets = [row[0] for row in cursor.fetchall()]

statuses = ['completed', 'in progress', 'planned']

records_to_insert = []

for _ in range(50):
    trip_type_id = random.choice(list(trip_type_durations.keys()))
    duration = trip_type_durations[trip_type_id]

    destination_id = random.choice(destinations)
    launch_station_id = random.choice(launch_stations)
    spacecraft_id = random.choice(spacecrafts)

    rocket_id = random.choice(rockets) 

    status = random.choices(statuses, weights=[0.4, 0.3, 0.3])[0]

    if status == 'completed':
        departure = start_of_business + timedelta(days=random.randint(0, 5*365 - duration))
        return_dt = departure + timedelta(days=duration)
    elif status == 'in progress':
        departure = datetime.now() - timedelta(days=random.randint(1, duration))
        return_dt = None
    else:
        departure = datetime.now() + timedelta(days=random.randint(1, 365))
        return_dt = None

    records_to_insert.append((
        trip_type_id,
        destination_id,
        launch_station_id,
        spacecraft_id,
        rocket_id,
        departure,
        return_dt,
        status
    ))

cursor.executemany(
    '''
    INSERT INTO trips (
        trip_type_id, destination_id, launch_station_id,
        spacecraft_id, rocket_id, departure_datetime,
        return_datetime, status
    ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
    ''',
    records_to_insert
)
con.commit()
```

## Generowanie pracowników do lotu (jest 35 na lot- mozna zmienić)

```{python}

excluded_positions = [
    'Finanse / Księgowość',
    'Analityk danych',
    'Marketing kosmiczny',
    'Administrator IT',
    'Specjalista HR'
]

# Pobierz pracowników z dozwolonych stanowisk
cursor.execute(
    '''
    SELECT employee_id, position
    FROM employees
    WHERE position NOT IN (%s)
    ''' % ','.join(['%s'] * len(excluded_positions)),
    excluded_positions
)
crew_data = cursor.fetchall()  # lista (employee_id, position)

# Grupuj pracowników wg pozycji
from collections import defaultdict
position_map = defaultdict(list)
for emp_id, pos in crew_data:
    position_map[pos].append(emp_id)


# Lista dozwolonych pozycji
allowed_positions = list(position_map.keys())

# Pobierz trip_id
cursor.execute('SELECT trip_id FROM trips')
trip_ids = [row[0] for row in cursor.fetchall()]

assignments = []

for trip_id in trip_ids:
    selected_employees = set()
    trip_assignment = []

    # Po 1 osobie z każdego stanowiska
    for position, emp_list in position_map.items():
        emp_id = random.choice(emp_list)
        selected_employees.add(emp_id)
        trip_assignment.append((trip_id, emp_id, position))

    # Dodaj losowych pracowników aż do 35 (unikalnych)
    remaining_pool = [
        (emp_id, pos)
        for pos, emp_ids in position_map.items()
        for emp_id in emp_ids
        if emp_id not in selected_employees
    ]
    additional_needed = 35 - len(trip_assignment)
    if additional_needed > 0:
        additional_crew = random.sample(remaining_pool, min(additional_needed, len(remaining_pool)))
        for emp_id, pos in additional_crew:
            selected_employees.add(emp_id)
            trip_assignment.append((trip_id, emp_id, pos))

    assignments.extend(trip_assignment)

cursor.executemany(
    '''
    INSERT INTO employee_assignments (trip_id, employee_id, role)
    VALUES (%s, %s, %s)
    ''',
    assignments
)
con.commit()


```

## Generowanie pasażerów dla lotów


```{python}

# Pobierz klientów
cursor.execute('SELECT client_id FROM clients')
client_ids = [row[0] for row in cursor.fetchall()]

# Pobierz loty wraz z przypisanymi statkami, statusem i datami
cursor.execute('SELECT trip_id, spacecraft_id, status, departure_datetime, return_datetime FROM trips')
trips_data = cursor.fetchall()  # lista (trip_id, spacecraft_id, status, departure_datetime, return_datetime)

# Pobierz pojemności statków
cursor.execute('SELECT spacecraft_id, capacity_passengers FROM spacecraft')
capacity_map = dict(cursor.fetchall())  # dict: spacecraft_id -> capacity

# Stwórz strukturę: trip_id -> (capacity, status, departure, return)
trip_info = {
    trip_id: (capacity_map[spacecraft_id], status, departure, return_dt)
    for trip_id, spacecraft_id, status, departure, return_dt in trips_data
}

# Przygotuj dane do INSERT
trip_participants = defaultdict(list)  # trip_id -> list of (client_id, seat_number)
client_trip_assignments = defaultdict(list)  # client_id -> list of (departure, return)

# Funkcja sprawdzająca nakładanie się przedziałów czasowych
def is_overlapping(new_start, new_end, existing_intervals):
    new_end = new_end or datetime.max
    for start, end in existing_intervals:
        end = end or datetime.max
        if new_start <= end and start <= new_end:
            return True
    return False

# 1. Zapełnij w pełni loty 'completed' i 'in progress'
filled_trips = [tid for tid, (_, status, _, _) in trip_info.items() if status in ('completed', 'in progress')]
available_clients = client_ids.copy()
random.shuffle(available_clients)

for trip_id in filled_trips:
    capacity, _, departure, return_dt = trip_info[trip_id]
    assigned = 0
    for client_id in available_clients:
        if assigned >= capacity:
            break
        if not is_overlapping(departure, return_dt, client_trip_assignments[client_id]):
            seat_number = len(trip_participants[trip_id]) + 1
            trip_participants[trip_id].append((client_id, seat_number))
            client_trip_assignments[client_id].append((departure, return_dt))
            assigned += 1

# 2. Upewnij się, że każdy klient jest przypisany do co najmniej jednego lotu
all_trip_ids = list(trip_info.keys())
random.shuffle(all_trip_ids)

for client_id in client_ids:
    if not client_trip_assignments[client_id]:
        for trip_id in all_trip_ids:
            capacity, _, departure, return_dt = trip_info[trip_id]
            if len(trip_participants[trip_id]) >= capacity:
                continue
            if not is_overlapping(departure, return_dt, client_trip_assignments[client_id]):
                seat_number = len(trip_participants[trip_id]) + 1
                trip_participants[trip_id].append((client_id, seat_number))
                client_trip_assignments[client_id].append((departure, return_dt))
                break

# 3. Uzupełnij loty 'planned' (częściowo)
for trip_id, (capacity, status, departure, return_dt) in trip_info.items():
    if status != 'planned':
        continue
    remaining_seats = capacity - len(trip_participants[trip_id])
    if remaining_seats <= 0:
        continue
    random.shuffle(client_ids)
    for client_id in client_ids:
        if remaining_seats == 0:
            break
        if not is_overlapping(departure, return_dt, client_trip_assignments[client_id]):
            seat_number = len(trip_participants[trip_id]) + 1
            trip_participants[trip_id].append((client_id, seat_number))
            client_trip_assignments[client_id].append((departure, return_dt))
            remaining_seats -= 1

# Przygotuj dane do INSERT
records_to_insert = [
    (trip_id, client_id, seat_number)
    for trip_id, participants in trip_participants.items()
    for client_id, seat_number in participants
]

cursor.executemany(
    '''
    INSERT INTO trip_participants (trip_id, client_id, seat_number)
    VALUES (%s, %s, %s)
    ''',
    records_to_insert
)
con.commit()


```

## Emergency contacts

```{python}


cursor.execute('SELECT client_id, date_of_birth FROM clients')
clients = cursor.fetchall()

# relacje rozdzielone według płci
male_relationships = ['ojciec', 'brat', 'mąż', 'partner', 'przyjaciel', 'syn']
female_relationships = ['matka', 'siostra', 'żona', 'partnerka', 'przyjaciółka', 'córka']

records_to_insert = []

for client_id, dob in clients:
    birth_year = dob.year
    if birth_year < 1965:
        available_relationships = male_relationships + female_relationships
        available_relationships = [r for r in available_relationships if r not in ['matka', 'ojciec']]
    elif birth_year > 1990:
        available_relationships = male_relationships + female_relationships
        available_relationships = [r for r in available_relationships if r not in ['syn', 'córka']]
    else:
        available_relationships = male_relationships + female_relationships

    used_relationships = set()
    for _ in range(2):
        while True:
            # losuj płeć kontaktu
            gender = random.choice(['male', 'female'])
            first_name = fake.first_name_male() if gender == 'male' else fake.first_name_female()
            last_name = fake.last_name()
            email = fake.email()
            phone = fake.phone_number()

            rel_pool = male_relationships if gender == 'male' else female_relationships
            # zawęź do dozwolonych relacji i tych jeszcze nieużytych
            rel_choices = [r for r in rel_pool if r in available_relationships and r not in used_relationships]

            if rel_choices:
                relationship = random.choice(rel_choices)
                used_relationships.add(relationship)
                break

        records_to_insert.append((
            client_id,
            first_name,
            last_name,
            relationship,
            email,
            phone
        ))

cursor.executemany(
    '''
    INSERT INTO emergency_contacts (
        client_id, first_name, last_name,
        relationship, email, phone
    ) VALUES (%s, %s, %s, %s, %s, %s)
    ''',
    records_to_insert
)

con.commit()


```