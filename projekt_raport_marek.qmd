---
title: "Projekt z Baz Danych – Raport Końcowy"
format:
  html:
    toc: true
    number-sections: true
    code-fold: true
    code-summary: "Rozwiń kod"
    theme:
      light: flatly
      dark: darkly
page-layout: full
---

# Autorzy

- Jakub Ciągło  
- Mateusz Ćwiek  
- Marek Dworaczyk  
- Rafał Głodek

# Importy
```{python}
import random
import math
from datetime import date, datetime, timedelta, time
import numpy as np
import pandas as pd
import mysql.connector
import plotly.express as px
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from scipy import stats
from sqlalchemy import create_engine
from urllib.parse import quote_plus
```


# Ustanowienie połączenia
```{python}

con = mysql.connector.connect(
    host = "giniewicz.it",
    user = "team13",
    password = "te@mlie",
    port=3306,
    use_pure=True,
    database = "team13"
)

cursor = con.cursor()

```

# Analiza danych

## Zadanie 3
Po których wycieczkach klienci wracają na kolejne, a po których mają dość i więcej ich nie widzicie. Czy są takie, które być może powinny zniknąć z oferty?

Jak do tego problemu podejść? Na początek stworzymy sobie dwa zbiory: id klientów którzy pojechali tylko na jedną podróż oraz klientów co pojechali na więcej podróży

```{python}
query = "SELECT client_id, COUNT(trip_id) as trips FROM  trip_participants GROUP BY client_id"

cursor.execute(query)

trips_of_client = np.array(cursor.fetchall())

single_trip = trips_of_client[trips_of_client[:,1] == 1][:,0]
multi_trip = trips_of_client[trips_of_client[:,1] != 1][:,0]

```

Teraz mamy wydzielonych klientów, którzy polecieli na wyprawę tylko raz i takich co polecieli więcej razy. Na początek zobaczmy jaka wycieczka odstraszyła tych co polecieli pierwszy raz.

```{python}

client_ids = list(map(int, single_trip.tolist()))

placeholders = ','.join(['%s'] * len(client_ids))

query = f"""
    SELECT trip_id, COUNT(*) as count
    FROM trip_participants
    WHERE client_id IN ({placeholders})
    GROUP BY trip_id
    ORDER BY count DESC
"""

cursor.execute(query, client_ids)
results = np.array(cursor.fetchall())

trip_ids = results[:,0]
trip_ids = list(map(int, trip_ids.tolist()))

```

Teraz chcemy wyświetlić listę tych wycieczek, co ma najwięcej jednorazowych klientów.

```{python}
trip_ids = [int(t) for t in trip_ids] 
placeholders = ','.join(['%s'] * len(trip_ids))

query = f"""
    SELECT 
        t.trip_id,
        d.name AS destination,
        tt.name AS trip_type,
        s.name AS spacecraft_name,
        r.name AS rocket_name,
        COUNT(tp.client_id) AS one_time_clients
    FROM trip_participants tp
    JOIN trips t ON tp.trip_id = t.trip_id
    JOIN spacecraft s ON t.spacecraft_id = s.spacecraft_id
    JOIN rockets r ON t.rocket_id = r.rocket_id
    JOIN destinations d ON t.destination_id = d.destination_id
    JOIN trip_types tt ON t.trip_type_id = tt.trip_type_id
    WHERE tp.trip_id IN ({placeholders})
      AND tp.client_id IN ({','.join(['%s'] * len(client_ids))})
    GROUP BY t.trip_id, d.name, tt.name
    ORDER BY COUNT(tp.client_id) DESC
"""

cursor.execute(query, trip_ids + client_ids)
results = cursor.fetchall()

df = pd.DataFrame(results, columns=["Id", "Planeta", "Typ wyprawy", "Spacecraft", "Rocket","Klienci jednorazowi"])
print(df.to_string(index=False))
```

To podsumowanie daje nam dużo informacji, z których możemy wyciągnąć wnioski.

Zajmijmy się teraz tym problemem z innej strony. Sprawdźmy który rodzaj podróży był ostatnim, dla każdego klienta.

```{python}
trip_ids = [int(t) for t in trip_ids] 
placeholders = ','.join(['%s'] * len(trip_ids))

query = f"""
SELECT
    tp.client_id,
    t.trip_id
FROM
    trip_participants tp
JOIN trips t ON tp.trip_id = t.trip_id
JOIN trip_types tt ON t.trip_type_id = tt.trip_type_id
WHERE
    t.departure_datetime = (
        SELECT MAX(t2.departure_datetime)
        FROM trip_participants tp2
        JOIN trips t2 ON tp2.trip_id = t2.trip_id
        WHERE tp2.client_id = tp.client_id
    )
ORDER BY tp.client_id;
"""

cursor.execute(query)
results = np.array(cursor.fetchall())


df = pd.DataFrame(results, columns=['client_id', 'trip_id'])

summary = df['trip_id'].value_counts().reset_index()
summary.columns = ['trip_id', 'num_clients']

summary = summary.sort_values(by='num_clients', ascending=False)

top_5_ids = summary.head(5)["trip_id"]

top_5_ids = [int(t) for t in top_5_ids] 
placeholders = ','.join(['%s'] * len(top_5_ids))

query = f"""
    SELECT 
        t.trip_id,
        d.name AS destination,
        tt.name AS trip_type,
        s.name AS spacecraft_name,
        r.name AS rocket_name,
        COUNT(tp.client_id) AS one_time_clients
    FROM trip_participants tp
    JOIN trips t ON tp.trip_id = t.trip_id
    JOIN spacecraft s ON t.spacecraft_id = s.spacecraft_id
    JOIN rockets r ON t.rocket_id = r.rocket_id
    JOIN destinations d ON t.destination_id = d.destination_id
    JOIN trip_types tt ON t.trip_type_id = tt.trip_type_id
    WHERE tp.trip_id IN ({placeholders})
    GROUP BY t.trip_id, d.name, tt.name
"""

cursor.execute(query, top_5_ids)
results = cursor.fetchall()

df = pd.DataFrame(results, columns = ["Id", "Planeta", "Rodzaj", "Spacecraft", "Rakieta", "Ilość"])
df = df.sort_values(by="Ilość", ascending=False)
print(df.to_string(index=False))
```

Teraz jak już zadalismy jakie wycieczki odstraszają naszych klientów, zobaczmy jakie wycieczki przyciągają ich.

```{python}
query= """
  SELECT tp.client_id, tp.trip_id,t.departure_datetime 
  FROM trip_participants tp
  JOIN trips t ON tp.trip_id = t.trip_id
  ORDER BY tp.client_id, t.departure_datetime;"""

cursor.execute(query)
results = np.array(cursor.fetchall())

df = pd.DataFrame(results,columns=["client_id","trip_id","departure"])

df['next_trip'] = df.groupby('client_id')['trip_id'].shift(-1)

df['returned_after'] = df['next_trip'].notna()


trip_retention = df[df['returned_after']].groupby('trip_id').size().reset_index(name='clients_returned')

trip_retention = trip_retention.sort_values(by='clients_returned', ascending=False)

top_5_ret_ids = trip_retention.head(5)["trip_id"]

top_5_ret_ids = [int(t) for t in top_5_ret_ids] 
placeholders = ','.join(['%s'] * len(top_5_ret_ids))

query = f"""
    SELECT 
        t.trip_id,
        d.name AS destination,
        tt.name AS trip_type,
        s.name AS spacecraft_name,
        r.name AS rocket_name
    FROM trip_participants tp
    JOIN trips t ON tp.trip_id = t.trip_id
    JOIN spacecraft s ON t.spacecraft_id = s.spacecraft_id
    JOIN rockets r ON t.rocket_id = r.rocket_id
    JOIN destinations d ON t.destination_id = d.destination_id
    JOIN trip_types tt ON t.trip_type_id = tt.trip_type_id
    WHERE tp.trip_id IN ({placeholders})
    GROUP BY t.trip_id, d.name, tt.name
"""

cursor.execute(query, top_5_ids)
results = cursor.fetchall()

df = pd.DataFrame(results, columns = ["Id", "Planeta", "Rodzaj", "Spacecraft", "Rakieta"])
print(df.to_string(index=False))

```

Po wykonaniu kodu który na pewno ja sam napisałem możemy zobaczyć jakie wycieczki są najbardziej zachęcające.

Teraz pora na to aby samemu wymyśleć jakieś ciekawe zapytania. Mam następujące pomysły które oczywiście wymyśliłem samemu.

## Zadanie 4

Wpływ pracowników na jakość podróży. Czy obecność konkretnego pracownika poprawia jakość podróży? Czy możemy wyznaczyć gwiazdę zespołu?

Wyznaczenie pracowników obecnych na wycieczkach o najwyższych ocenach jest proste, ale co dalej?

Może należy wziąć pracownika pod lupę i sprawdzić czy on naprawdę ma wysoką średnią ocen, czy po prostu jest obecny na wielu lotach.

```{python}
query="""
SELECT
e.employee_id,
position,
COUNT(*) AS success
FROM trips t
JOIN feedback f ON f.trip_id = t.trip_id
JOIN employee_assignments ea ON ea.trip_id = t.trip_id
JOIN employees e ON ea.employee_id = e.employee_id
WHERE rating > 3
GROUP BY ea.employee_id
ORDER BY success DESC
"""

cursor.execute(query)
results = cursor.fetchall()
df = pd.DataFrame(results, columns = ["Id", "Pozycja","Ilość pozytywnych tripów"])
df

```


## Zadanie 5

Trend i sezonowość. Czy jest ona związana z incydentami?


```{python}
query = """
SELECT
*
FROM transactions ta
WHERE status LIKE "completed"
"""
```

2. Czasowe trendy i sezonowość. Czy są miesiące z większą liczbą incydentów lub niższymi ocenami?
3. Najbardziej pracowity pracownik?
4. Pracownik x spacecraft?
5. Najbardziej zużyty spacecraft/rocket? Który lata najdłużej i który ma za sobą najwięcej podróży?
6. Trend i sezonowość. Czy jest ona związana z incydentami?
7. Ulubione metody płatności naszych klientów. Z jakiego źródła wpływa najwięcej pieniędzy. Czy może mamy rozwinąć ten system

##