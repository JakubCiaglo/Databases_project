---
title: "Projekt z Baz Danych – Raport Końcowy"
format:
  html:
    toc: true
    number-sections: true
    code-fold: true
    code-summary: "Rozwiń kod"
    theme:
      light: flatly
      dark: darkly
page-layout: full
---

# Autorzy

- Jakub Ciągło  
- Mateusz Ćwiek  
- Marek Dworaczyk  
- Rafał Głodek

# Importy
```{python}
import random
import math
from datetime import date, datetime, timedelta, time
import numpy as np
import pandas as pd
import mysql.connector
import plotly.express as px
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from datetime import datetime
from scipy import stats
from sqlalchemy import create_engine
from urllib.parse import quote_plus
```


# Ustanowienie połączenia
```{python}

con = mysql.connector.connect(
    host = "giniewicz.it",
    user = "team13",
    password = "te@mlie",
    port=3306,
    use_pure=True,
    database = "team13"
)

cursor = con.cursor()

```

# Analiza danych

## Zadanie 3
Po których wycieczkach klienci wracają na kolejne, a po których mają dość i więcej ich nie widzicie. Czy są takie, które być może powinny zniknąć z oferty?

Najpierw zajmiemy się tymi wyprawami, które odstraszają naszych klientów. Wyszukamy na początke dwie rzeczy: wszystkie rodzaje wycieczek, które miały pojedyńczych klientów, a następnie wyszukamy zbiór wycieczek, które były ostatnimi dla klientów.

Mają te infomacje stworzymy zestawienie aspektów, które mogły przyczynić się do negatywnego odbioru przez klientów (najgorsza planeta, typ wyprawy, najmniej przyjemny pojazd itp.)

Zebranie tych tripów, które są miały najwięcej jednorazowych klientów.
```{python}
def df_summary(df):
    # dataframe składa się z trzech interesujących nas aspektów, planeta, rodzaj i pojazd


    summary_planeta = df['Planeta'].value_counts().reset_index()
    summary_planeta.columns = ['Planeta', 'liczba']

    summary_typ = df['Rodzaj'].value_counts().reset_index()
    summary_typ.columns = ['Rodzaj', 'liczba']

    summary_pojazd = df['Spacecraft'].value_counts().reset_index()
    summary_pojazd.columns = ['Spacecraft', 'liczba']

    if summary_planeta["liczba"][0] == 1:
        print("Wszystkie planety występują równie często")
    else:
        print("Najczęściej występująca planeta:", summary_planeta["Planeta"][0] )

    if summary_typ["liczba"][0] == 1:
        print("Wszystkie wycieczki występują równie często")
    else:
        print("Najczęściej występująca wycieczka:", summary_typ["Rodzaj"][0] )

    if summary_pojazd["liczba"][0] == 1:
        print("Wszystkie pojazdy występują równie często")
    else:
        print("Najczęściej występujący pojazd:", summary_pojazd["Spacecraft"][0] )    
```

```{python}
query_one_timers = """SELECT 
    client_id, 
    COUNT(trip_id) as trips 
    FROM  trip_participants 
    GROUP BY client_id
    HAVING trips = 1"""
cursor.execute(query_one_timers)
one_time_clients = np.array(cursor.fetchall())
one_time_ids = one_time_clients[:,0]

client_ids = list(map(int, one_time_ids.tolist()))
placeholders = ','.join(['%s'] * len(client_ids))

query_one_time_trips = f"""
    SELECT trip_id, COUNT(*) as count
    FROM trip_participants
    WHERE client_id IN ({placeholders})
    GROUP BY trip_id
    ORDER BY count DESC
"""
cursor.execute(query_one_time_trips, client_ids)
results = np.array(cursor.fetchall())

one_time_trips = results[:,0]

trip_ids = [int(t) for t in one_time_trips] 
placeholders = ','.join(['%s'] * len(trip_ids))

query_trip_info = f"""
    SELECT 
        t.trip_id,
        d.name AS destination,
        tt.name AS trip_type,
        s.name AS spacecraft_name,
        r.name AS rocket_name
    FROM trip_participants tp
    JOIN trips t ON tp.trip_id = t.trip_id
    JOIN spacecraft s ON t.spacecraft_id = s.spacecraft_id
    JOIN rockets r ON t.rocket_id = r.rocket_id
    JOIN destinations d ON t.destination_id = d.destination_id
    JOIN trip_types tt ON t.trip_type_id = tt.trip_type_id
    WHERE tp.trip_id IN ({placeholders})
    GROUP BY t.trip_id, d.name, tt.name
"""
cursor.execute(query_trip_info, trip_ids)
results = cursor.fetchall()

df_disliked_trips = pd.DataFrame(results, columns=["Id", "Planeta", "Rodzaj", "Spacecraft", "Rocket"])

print(df_disliked_trips.to_string(index=False))
```

Jeśli tutaj jest za dużo informacji to możemy zrobić na dole małe podsumowanie 

```{python}
df_summary(df_disliked_trips)
```

Zajmijmy się teraz tym problemem z innej strony. Sprawdźmy który rodzaj podróży był ostatnim, dla każdego klienta.

```{python}
placeholders = ','.join(['%s'] * len(one_time_ids))
one_time_ids = [int(t) for t in one_time_ids] 

query_last_trips = f"""
SELECT
    tp.client_id,
    t.trip_id
FROM
    trip_participants tp
JOIN trips t ON tp.trip_id = t.trip_id
WHERE
    tp.client_id NOT IN ({placeholders})
    AND t.departure_datetime = (
        SELECT MAX(t2.departure_datetime)
        FROM trip_participants tp2
        JOIN trips t2 ON tp2.trip_id = t2.trip_id
        WHERE tp2.client_id = tp.client_id
    )
ORDER BY tp.client_id;
"""

cursor.execute(query_last_trips, one_time_ids)
results = np.array(cursor.fetchall())


df = pd.DataFrame(results, columns=['client_id', 'trip_id'])

summary = df['trip_id'].value_counts().reset_index()
summary.columns = ['trip_id', 'num_clients']

summary = summary.sort_values(by='num_clients', ascending=False)
last_trips_ids = summary["trip_id"]

last_trips_ids = [int(t) for t in last_trips_ids] 
placeholders = ','.join(['%s'] * len(last_trips_ids))

query_trip_info = f"""
    SELECT 
        t.trip_id,
        d.name AS destination,
        tt.name AS trip_type,
        s.name AS spacecraft_name,
        r.name AS rocket_name
    FROM trip_participants tp
    JOIN trips t ON tp.trip_id = t.trip_id
    JOIN spacecraft s ON t.spacecraft_id = s.spacecraft_id
    JOIN rockets r ON t.rocket_id = r.rocket_id
    JOIN destinations d ON t.destination_id = d.destination_id
    JOIN trip_types tt ON t.trip_type_id = tt.trip_type_id
    WHERE tp.trip_id IN ({placeholders})
    GROUP BY t.trip_id, d.name, tt.name
"""

cursor.execute(query_trip_info, last_trips_ids)
results = cursor.fetchall()

df_last_trips = pd.DataFrame(results, columns = ["Id", "Planeta", "Rodzaj", "Spacecraft", "Rakieta"])
print(df_last_trips.to_string(index=False))
```

```{python}
df_summary(df_last_trips)
```

Tutaj mamy podobne info, jednak to są wszystkie tripy, dla których klienci lecieli więcej niż raz.

Teraz mamy dwa data_frame'y, które nam mówią o tym, które tripy były najczęściej jednorazowe, a które były ostatnimi dal tych co polecieli częściej niż raz. 
Napiszmy teraz funkcję która zrobi nam podsumowanie tych tabel pod wzlędem: planet, rodzajów wypraw, statków


Teraz dla odmiany zobaczmy jakie wycieczki są bardziej zachęcające.

```{python}
query= """
  SELECT tp.client_id, tp.trip_id,t.departure_datetime 
  FROM trip_participants tp
  JOIN trips t ON tp.trip_id = t.trip_id
  ORDER BY tp.client_id, t.departure_datetime;"""

cursor.execute(query)
results = np.array(cursor.fetchall())

df = pd.DataFrame(results,columns=["client_id","trip_id","departure"])

df['next_trip'] = df.groupby('client_id')['trip_id'].shift(-1)

df['returned_after'] = df['next_trip'].notna()


trip_retention = df[df['returned_after']].groupby('trip_id').size().reset_index(name='clients_returned')
trip_retention = trip_retention.sort_values(by='clients_returned', ascending=False)
top_5_ret_ids = trip_retention.head(5)["trip_id"]
top_5_ret_ids = [int(t) for t in top_5_ret_ids] 
placeholders = ','.join(['%s'] * len(top_5_ret_ids))

query = f"""
    SELECT 
        t.trip_id,
        d.name AS destination,
        tt.name AS trip_type,
        s.name AS spacecraft_name,
        r.name AS rocket_name
    FROM trip_participants tp
    JOIN trips t ON tp.trip_id = t.trip_id
    JOIN spacecraft s ON t.spacecraft_id = s.spacecraft_id
    JOIN rockets r ON t.rocket_id = r.rocket_id
    JOIN destinations d ON t.destination_id = d.destination_id
    JOIN trip_types tt ON t.trip_type_id = tt.trip_type_id
    WHERE tp.trip_id IN ({placeholders})
    GROUP BY t.trip_id, d.name, tt.name
"""
cursor.execute(query, top_5_ret_ids)
results = cursor.fetchall()

df_liked_trips = pd.DataFrame(results, columns = ["Id", "Planeta", "Rodzaj", "Spacecraft", "Rakieta"])
print(df_liked_trips.to_string(index=False))
```

```{python}
df_summary(df_liked_trips)
```

Wszystko mamy, możemy teraz napisać ładne podsumowanie.

## Zadanie 4
### Analiza pracowników: najbardziej lubiany i najbardziej pracowity

Wpływ pracowników na jakość podróży. Czy obecność konkretnego pracownika poprawia jakość podróży? Czy możemy wyznaczyć gwiazdę zespołu?
Wyznaczenie pracowników obecnych na wycieczkach o najwyższych ocenach jest proste, ale co dalej?

```{python}
query="""
SELECT DISTINCT(position) from employees
"""

cursor.execute(query)
results = cursor.fetchall()
roles=""
for i in range(len(results)):
    roles += results[i][0] +", "

print(roles[:-2])
```

Inżynier systemów, Administrator IT, Technik pokładowy, Analityk danych, Marketing kosmiczny, Inspektor jakości, Pilot statku, Specjalista ds. bezpieczeństwa, Finanse / Księgowość, Astrogator, Mechanik rakietowy, Lekarz pokładowy, Kontroler lotów, Kucharz orbitalny, Specjalista HR

Pilot statku, Specjalista ds. bezpieczeństwa,Lekarz pokładowy, Kucharz orbitalny

```{python}
roles_of_interest = ["Pilot statku", "Specjalista ds. bezpieczeństwa","Lekarz pokładowy", "Kucharz orbitalny"]
```

Zobaczmy
```{python}
placeholders = ','.join(['%s'] * len(roles_of_interest))
query = f"""
SELECT
    ea.employee_id,
    e.first_name,
    e.last_name,
    e.position,
    f.trip_id,
    f.rating
FROM employee_assignments ea
JOIN employees e ON ea.employee_id = e.employee_id
JOIN feedback f ON ea.trip_id = f.trip_id
WHERE e.position IN ({placeholders})
"""

cursor.execute(query, roles_of_interest)
results = cursor.fetchall()
```

```{python}
import pandas as pd

df = pd.DataFrame(results, columns=["employee_id", "first_name", "last_name", "position", "trip_id", "rating"])

# Oblicz średnią ocenę dla każdego pracownika
avg_ratings = df.groupby(['employee_id', 'first_name', 'last_name', 'position'])['rating'].mean().reset_index()

# Posortuj od najwyższej
avg_ratings = avg_ratings.sort_values(by="rating", ascending=False)

# Pokaż topowych pracowników
print(avg_ratings.head(10))
```

=================================================================

```{python}

query="""
SELECT
    ea.employee_id,
    e.first_name,
    e.last_name,
    e.position,
    COUNT(ea.trip_id) AS trips_assigned
FROM employee_assignments ea
JOIN employees e ON ea.employee_id = e.employee_id
GROUP BY ea.employee_id, e.first_name, e.last_name, e.position
ORDER BY trips_assigned DESC;
"""
cursor.execute(query)
results = cursor.fetchall()
# Załaduj dane z SQL do DataFrame
df_acvitivy = pd.DataFrame(results, columns=["employee_id", "first_name", "last_name", "position", "trips_assigned"])


# Filtrowanie po roli
filtered_df = df_acvitivy[df_acvitivy["position"].isin(roles_of_interest)]

# Posortuj i pokaż najbardziej pracowitych w wybranych rolach
most_active = df_acvitivy.sort_values(by="trips_assigned", ascending=False)
most_active_of_interest = filtered_df.sort_values(by="trips_assigned", ascending=False)

print(most_active.head(10))
print("===================================")
print(most_active_of_interest.head(10))

```





Czy można jakoś wyznaczyć korelację pomiędzy pracownikami i oceną?
Może należy wziąć pracownika pod lupę i sprawdzić czy on naprawdę ma wysoką średnią ocen, czy po prostu jest obecny na wielu lotach.




```{python}
query="""
SELECT
e.employee_id,
position,
COUNT(*) AS success
FROM trips t
JOIN feedback f ON f.trip_id = t.trip_id
JOIN employee_assignments ea ON ea.trip_id = t.trip_id
JOIN employees e ON ea.employee_id = e.employee_id
WHERE rating > 3
GROUP BY ea.employee_id
ORDER BY success DESC
"""

cursor.execute(query)
results = cursor.fetchall()
df = pd.DataFrame(results, columns = ["Id", "Pozycja","Ilość pozytywnych tripów"])
df

```


## Zadanie 5

Trend i sezonowość. Czy jest ona związana z incydentami?



```{python}
query = """SELECT trip_id, departure_datetime FROM trips;"""
cursor.execute(query)
results = cursor.fetchall()

df = pd.DataFrame(results, columns=["trip_id","departure_datetime"])

dates = [str(s) for s in df["departure_datetime"]] 
df["departure_datetime"] = dates

df['departure_datetime'] = df['departure_datetime'].apply(lambda x: datetime.strptime(x, '%Y-%m-%d %H:%M:%S'))
df['year_month'] = df['departure_datetime'].apply(lambda x: f"{x.year}-{x.month:02d}")
df['year'] = df['departure_datetime'].apply(lambda x: x.year)
df['month'] = df['departure_datetime'].apply(lambda x: x.month)

# trip_counts = df['year_month'].value_counts().sort_index()

# trip_counts.plot(kind='bar', figsize=(15, 5))
# plt.title("Liczba wycieczek w czasie")
# plt.xlabel("Rok-miesiąc")
# plt.ylabel("Liczba wycieczek")
# plt.xticks(rotation=45)
# plt.tight_layout()
# plt.show()

# a może po miesiącach

trip_counts = df['month'].value_counts().sort_index()

trip_counts.plot(kind='bar', figsize=(15, 5))
plt.title("Liczba wycieczek w czasie")
plt.xlabel("Miesiąc")
plt.ylabel("Liczba wycieczek")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()
```

Imo miesiącie lepiej wypadają, spróbujmy zrobić to teraz dla incydentów

```{python}
query = """SELECT incident_id, datetime_occurred FROM incidents;"""
cursor.execute(query)
results = cursor.fetchall()

df = pd.DataFrame(results, columns=["id","datetime"])

dates = [str(s) for s in df["datetime"]] 
df["datetime"] = dates
df['datetime'] = df['datetime'].apply(lambda x: datetime.strptime(x, '%Y-%m-%d %H:%M:%S'))
df['year_month'] = df['datetime'].apply(lambda x: f"{x.year}-{x.month:02d}")
df['year'] = df['datetime'].apply(lambda x: x.year)
df['month'] = df['datetime'].apply(lambda x: x.month)

incidents_counts = df['month'].value_counts().sort_index()

incidents_counts.plot(kind='bar', figsize=(15, 5))
plt.title("Liczba wycieczek w czasie")
plt.xlabel("Miesiąc")
plt.ylabel("Liczba wycieczek")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()
```

Wyrysujmy teraz te dwie rzeczy na jednym histogramie

```{python}
all_months = list(range(1, 13))
trip_counts = trip_counts.reindex(all_months, fill_value=0)
incidents_counts = incidents_counts.reindex(all_months, fill_value=0)

x = np.arange(len(all_months))
width = 0.35

fig, ax = plt.subplots(figsize=(10, 5))

bars1 = ax.bar(x - width/2, trip_counts.values, width, label='Liczba wycieczek')
bars2 = ax.bar(x + width/2, incidents_counts.values, width, label='Liczba incydentów')

ax.set_xlabel('Miesiąc')
ax.set_ylabel('Liczba')
ax.set_title('Porównanie liczby wycieczek i incydentów wg miesiąca')
ax.set_xticks(x)
ax.set_xticklabels([f"{m:02d}" for m in all_months])
ax.legend()

plt.tight_layout()
plt.show()
```


2. Czy klienci dokonują płatności za przejazdy z wyprzedzeniem, czy czekają do ostatniej chwili?

```{python}
query="""SELECT
    ts.client_id,
    ts.trip_id,
    ts.transaction_date,
    t.departure_datetime,
    DATEDIFF(t.departure_datetime, ts.transaction_date) AS days_before_trip
FROM transactions ts
JOIN trips t ON ts.trip_id = t.trip_id;"""

cursor.execute(query)
results = cursor.fetchall()
df = pd.DataFrame(results, columns=["client_id","trip_id","transaction_date","departure_date","diff"])

bins = [-100, 0, 3, 7, 14, 30, 90, 365]
labels = ['Po czasie', '0-3 dni', '4-7 dni', '8-14 dni', '15-30 dni', '31-90 dni', '91+ dni']
df['payment_window'] = pd.cut(df['diff'], bins=bins, labels=labels)

summary = df['payment_window'].value_counts().sort_index()

summary.plot(kind='bar', color='skyblue')
plt.title('Kiedy klienci płacą za wycieczki?')
plt.xlabel('Ile dni przed wyjazdem dokonano płatności')
plt.ylabel('Liczba płatności')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

```



3. Ulubione metody płatności naszych klientów. Z jakiego źródła wpływa najwięcej pieniędzy. Czy może mamy rozwinąć ten system

```{python}
query="""SELECT
    payment_method,
    COUNT(*) AS total_transactions,
    SUM(amount) AS total_amount
FROM transactions
WHERE status = 'completed'
GROUP BY payment_method
ORDER BY total_amount DESC;"""

cursor.execute(query)
results = cursor.fetchall()
df_methods = pd.DataFrame(results, columns=["payment_method","total_transactions","total_amount"])

bins = [-100, 0, 3, 7, 14, 30, 90, 365]
labels = ['Po czasie', '0-3 dni', '4-7 dni', '8-14 dni', '15-30 dni', '31-90 dni', '91+ dni']
df['payment_window'] = pd.cut(df['diff'], bins=bins, labels=labels)

plt.figure(figsize=(10,6))
plt.bar(df_methods["payment_method"], df_methods["total_amount"], color='skyblue')
plt.xlabel("Metoda płatności")
plt.ylabel("Łączna kwota (PLN lub waluta)")
plt.title("Źródła największego przychodu wg metody płatności")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Drugi wykres - liczba transakcji
plt.figure(figsize=(10,6))
plt.bar(df_methods["payment_method"], df_methods["total_transactions"], color='lightgreen')
plt.xlabel("Metoda płatności")
plt.ylabel("Liczba transakcji")
plt.title("Popularność metod płatności wg liczby użyć")
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

```

##