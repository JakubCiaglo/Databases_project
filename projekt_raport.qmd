---
title: "Gwiezdne Horyzonty 2125"
subtitle: "Roczna Analiza Strategiczna Space-U"
author: "Zespół Analiz Biznesowych Space-U"
lang: pl-PL
date: "2125-06-13"
date-format: "long"
format:
  html:
    toc: true
    number-sections: true
    code-fold: true
    theme:
      light: flatly
      dark: darkly
page-layout: full
---

# Wstęp
W bezkresie kosmosu, podobnie jak w oceanie danych, kluczem do sukcesu jest precyzyjna nawigacja. Od ponad dekady misją Space-U jest nie tylko otwieranie ludzkości drogi do gwiazd, ale również prowadzenie tej ekspansji w sposób mądry, zrównoważony i rentowny. Rok 2034 był kolejnym kamieniem milowym na naszej orbicie sukcesu – rokiem, w którym umocniliśmy naszą pozycję lidera, wysłaliśmy rekordową liczbę pasażerów ku czerwonym piaskom Marsa i zorzom Jowisza, ale także zmierzyliśmy się z nowymi, nieprzewidzianymi wyzwaniami.

Niniejszy raport jest naszą mapą nawigacyjną po minionym roku. Z kosmiczną precyzją przeanalizowaliśmy zebrane dane, aby odpowiedzieć na fundamentalne pytania. Które trajektorie lotów przynoszą największe zyski? Jak zmienia się profil demograficzny naszych międzyplanetarnych podróżników? Gdzie leżą ukryte ryzyka operacyjne – czy to w pasie asteroid, czy w awaryjności naszych statków? I wreszcie – jak odczucia i oceny naszych klientów korelują z incydentami napotkanymi w drodze na orbitę?

Celem tego dokumentu nie jest jedynie kronikarski zapis przeszłości. To przede wszystkim kompas, który ma wskazać kierunek przyszłych działań. Wnioski tu zawarte stanowią solidny, oparty na twardych danych fundament pod strategiczne decyzje, które wyznaczą kurs Space-U na kolejne lata. Informacje te pozwolą nam nie tylko optymalizować obecne operacje, ale także odkrywać zupełnie nowe konstelacje możliwości rynkowych.

Zapnijcie pasy. Wyruszamy w podróż po danych, która ukształtuje przyszłość międzyplanetarnych podróży.

Z analitycznym pozdrowieniem,

Zespół Analiz Biznesowych Space-U

# Analiza danych

```{python}
#| echo: false
#| include: false
import random
import math
from datetime import date, datetime, timedelta, time
import numpy as np
import pandas as pd
import mysql.connector
import plotly.express as px
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from scipy import stats
from sqlalchemy import create_engine
from urllib.parse import quote_plus
from pandas.tseries.offsets import DateOffset 
import plotly.io as pio
from IPython.display import Markdown
pio.templates.default = "plotly_white" 
```

```{python}
#| echo: false
#| include: false
host = "giniewicz.it"
user = "team13"
password = "te@mlie"
database = "team13"
safe_password = quote_plus(password)

connection_uri = f"mysql+mysqlconnector://{user}:{safe_password}@{host}/{database}"
engine = create_engine(connection_uri)
```

## Analiza rentowności i popularności wypraw

W tej kluczowej sekcji raportu dokonujemy szczegółowego przeglądu naszego portfolio usług. Naszym celem jest precyzyjne zidentyfikowanie, które rodzaje wypraw stanowią trzon naszej oferty – ciesząc się największym zainteresowaniem klientów – oraz, co najważniejsze, jak popularność ta przekłada się na wyniki finansowe. Zrozumienie rentowności poszczególnych "produktów" jest fundamentem do podejmowania świadomych decyzji o alokacji zasobów, strategii cenowej i przyszłych inwestycjach w rozwój floty oraz nowych tras.

Analiza została przeprowadzona na podstawie pełnych danych operacyjnych i finansowych z czterech lat działalności naszej firmy. Wykorzystaliśmy do tego bezpośrednie zapytanie do naszej centralnej bazy danych, agregując informacje o liczbie lotów, całkowitych kosztach misji oraz skompletowanych transakcjach.

```{python}
query = """
SELECT
    tt.name AS 'Rodzaj wyprawy',
    COUNT(t.trip_id) AS 'Liczba wypraw',
    COALESCE(SUM(ac.total_trip_cost), 0) AS 'Całkowite koszty',
    COALESCE(SUM(ar.total_trip_revenue), 0) AS 'Całkowite przychody',
    (COALESCE(SUM(ar.total_trip_revenue), 0) - COALESCE(SUM(ac.total_trip_cost), 0)) AS 'Zysk'
FROM
    trip_types tt
LEFT JOIN
    trips t ON tt.trip_type_id = t.trip_type_id
LEFT JOIN
    (SELECT trip_id, SUM(cost_amount) AS total_trip_cost FROM costs GROUP BY trip_id) ac 
    ON t.trip_id = ac.trip_id
LEFT JOIN
    (SELECT trip_id, SUM(amount) AS total_trip_revenue FROM transactions WHERE status = 'Completed' GROUP BY trip_id) ar 
    ON t.trip_id = ar.trip_id
GROUP BY
    tt.name
ORDER BY
    `Liczba wypraw` DESC;
"""
```

Poniższa tabela prezentuje kompleksowe zestawienie kluczowych wskaźników dla każdego typu wyprawy

```{python}
df_profitability = pd.read_sql(query, engine)

display(df_profitability.style.format('{:,.2f} zł', subset=['Całkowite koszty', 'Całkowite przychody', 'Zysk'], decimal=',', thousands=' ')\
                         .format('{}', subset=['Liczba wypraw'])\
                         .set_caption("Popularność i rentowność typów wypraw")\
                         .background_gradient(cmap='RdYlGn', subset=['Zysk']))
```
```{python}
#| echo: false
#| include: false
print("\n\n--- Wnioski ---")
print("\nNajpopularniejsze rodzaje wypraw:\n")
top_3_profitability = df_profitability.head(3)

for index, row in top_3_profitability.iterrows():
    print(
        f"{index + 1}. Rodzaj '{row['Rodzaj wyprawy']}': "
        f"{row['Liczba wypraw']} wypraw, "
        f"które przyniosły {row['Całkowite przychody']:.2f} przychodu."
    )

print("\nAnaliza rentowności rodzajów wypraw:\n")
unprofitable_types = df_profitability[df_profitability['Zysk'] < 0]
if unprofitable_types.empty:
    print("Wszystkie rodzaje wypraw są opłacalne i nie przynoszą strat.")
else:
    print("UWAGA! Następujące rodzaje wypraw przynoszą straty:")
    for index, row in unprofitable_types.iterrows():
        print(
            f"- '{row['Rodzaj wyprawy']}': zanotowano stratę w wysokości {-row['Zysk']:.2f}"
        )

print("\n----------------------------------")
```

```{python}
#| echo: false
#| label: wyswietl-popularnosc

from IPython.display import Markdown

# --- Obliczenia ---
top_3_profitability = df_profitability.head(3)
wnioski_markdown = """
### Liderzy Popularności
Nasze dane jednoznacznie wskazują na grupę flagowych produktów, które stanowią o sile naszej marki. Poniżej przedstawiamy TOP 3 najchętniej wybierane wyprawy:
<ul>
"""

for _, row in top_3_profitability.iterrows():
    liczba_wypraw_str = f"<b>{row['Liczba wypraw']}</b>"
    przychody_str = f"<b>{row['Całkowite przychody']:,.2f} zł</b>"
    wnioski_markdown += (
        f"<li><b>{row['Rodzaj wyprawy']}</b>: zrealizowano {liczba_wypraw_str} wypraw, "
        f"które przyniosły {przychody_str} przychodu.</li>\n"
    )

wnioski_markdown += "</ul>"

# --- Wyświetlanie ---
display(Markdown(wnioski_markdown))
```

```{python}
#| echo: false
#| label: wyswietl-rentownosc

from IPython.display import Markdown

# --- Obliczenia ---
unprofitable_types = df_profitability[df_profitability['Zysk'] < 0]

rentownosc_markdown = """
### Analiza Rentowności
"""

if unprofitable_types.empty:
    rentownosc_markdown += (
        "<p style='color: #198754;'><b>Doskonałe wieści:</b> W analizowanym okresie wszystkie oferowane przez Space-U rodzaje wypraw "
        "okazały się rentowne. To świadczy o zdrowej strukturze kosztów i dobrze skalibrowanej polityce cenowej w całym naszym portfolio.</p>"
    )
else:
    rentownosc_markdown += (
        "<p style='color: #dc3545;'><b>Uwaga Zarządcza:</b> Zidentyfikowano następujące rodzaje wypraw, które generują straty. "
        "Rekomendujemy przeprowadzenie dogłębnej analizy ich struktury kosztów oraz efektywności operacyjnej:</p>"
        "<ul>"
    )
    for _, row in unprofitable_types.iterrows():
        strata_str = f"<b style='color: #dc3545;'>{-row['Zysk']:,.2f} zł</b>"
        rentownosc_markdown += f"<li><b>{row['Rodzaj wyprawy']}</b>: zanotowano stratę w wysokości {strata_str}.</li>\n"
    rentownosc_markdown += "</ul>"

# --- Wyświetlanie ---
display(Markdown(rentownosc_markdown))
```

## Problem drugi
Pytanie: Sporządź wykres liczby obsłużonych klientów w każdym miesiącu działalności firmy, czy firma rośnie, czy podupada?

```{python}
query_clients_per_month = """
SELECT
    DATE_FORMAT(t.departure_datetime, '%Y-%m') AS miesiac,
    COUNT(tp.client_id) AS liczba_klientow
FROM
    trips t
JOIN
    trip_participants tp ON t.trip_id = tp.trip_id
GROUP BY
    miesiac
ORDER BY
    miesiac ASC;
"""
```
```{python}
df_clients = pd.read_sql(query_clients_per_month, engine)
```

```{python}
plt.figure(figsize=(14, 7))
sns.barplot(data=df_clients, x='miesiac', y='liczba_klientow', color='steelblue')
plt.title('Miesięczna liczba obsłużonych klientów', fontsize=16)
plt.xlabel('Miesiąc', fontsize=12)
plt.ylabel('Liczba klientów', fontsize=12)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()
```

```{python}
import plotly.express as px

# Jeśli 'miesiac' to np. "3025-01", możesz zamienić go na string typu "2025-01"
df_clients['miesiac_str'] = df_clients['miesiac'].astype(str)
df_clients = df_clients.sort_values(by='miesiac_str')  # ręczne sortowanie

# Poprawki układu
fig = px.bar(df_clients,
             x='miesiac_str',
             y='liczba_klientow',
             text='liczba_klientow',
             title='Miesięczna liczba obsłużonych klientów',
             labels={'miesiac_str': 'Miesiąc', 'liczba_klientow': 'Liczba Klientów'},
             color_discrete_sequence=['#4c6ef5'])

fig.update_layout(xaxis_tickangle=-45)
fig.update_traces(textposition='outside')
fig.show()


```

```{python}
x = np.arange(len(df_clients)) 
y = df_clients['liczba_klientow'] 
slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)
# Ustalamy próg "stagnacji", aby uniknąć klasyfikowania bardzo małych wahań
# jako trendu. Np. jeśli wzrost/spadek jest mniejszy niż 0.5 klienta na miesiąc.
stagnation_threshold = 0.5

if slope > stagnation_threshold:
    wniosek = f"Firma wykazuje wyraźny trend WZROSTOWY."
    szczegoly = f"Średnio, z każdym miesiącem liczba klientów rośnie o {slope:.2f}."
elif slope < -stagnation_threshold:
    wniosek = f"Firma wykazuje wyraźny trend SPADKOWY."
    szczegoly = f"Średnio, z każdym miesiącem liczba klientów maleje o {-slope:.2f}."
else:
    wniosek = "Firma wykazuje STAGNACJĘ."
    szczegoly = f"Brak wyraźnego trendu wzrostowego lub spadkowego (nachylenie linii trendu wynosi {slope:.2f})."
print("--- Automatyczna Analiza Trendu ---")
print(f"Współczynnik nachylenia linii trendu: {slope:.4f}")
print(f"\nWniosek: {wniosek}")
print(szczegoly)
print("-----------------------------------")
```

## Problem trzeci
Pytanie: Które destynacje są najbardziej ryzykowne?

```{python}
query_risky_destinations = """
SELECT 
    destinations.name AS kierunek, 
    COUNT(*) AS liczba_wypadkow
FROM
    incidents
LEFT JOIN
    trips
ON
    incidents.trip_id = trips.trip_id
LEFT JOIN
    destinations
ON
    trips.destination_id = destinations.destination_id
GROUP BY
    kierunek
ORDER BY
    liczba_wypadkow DESC;
"""
```
```{python}
query_risky_dest2 = """
SELECT
    d.name AS kierunek,
    COALESCE(tpd.total_trips, 0) AS liczba_wypraw,
    COALESCE(ipd.total_incidents, 0) AS liczba_incydentow,
    (COALESCE(ipd.total_incidents, 0) * 100.0 / tpd.total_trips) AS wskaznik_ryzyka_procent
FROM
    destinations d
JOIN
    -- Pierwsze podzapytanie zdefiniowane bezpośrednio w FROM
    (
        SELECT destination_id, COUNT(trip_id) AS total_trips
        FROM trips
        GROUP BY destination_id
    ) AS tpd ON d.destination_id = tpd.destination_id
LEFT JOIN
    -- Drugie podzapytanie zdefiniowane bezpośrednio w FROM
    (
        SELECT t.destination_id, COUNT(i.incident_id) AS total_incidents
        FROM incidents i
        JOIN trips t ON i.trip_id = t.trip_id
        GROUP BY t.destination_id
    ) AS ipd ON d.destination_id = ipd.destination_id
ORDER BY
    wskaznik_ryzyka_procent DESC;
"""
```
```{python}
df_risky_destinations = pd.read_sql(query_risky_destinations, engine)
```
```{python}
print(df_risky_destinations.to_string())
```
```{python}
df_risky_destinations2 = pd.read_sql(query_risky_dest2, engine)
```
```{python}
print(df_risky_destinations2.to_string())
```

```{python}
query_incidents_graph = """
SELECT
    d.name AS kierunek,
    i.severity,
    COUNT(i.incident_id) AS liczba_incydentow
FROM
    incidents i
JOIN
    trips t ON i.trip_id = t.trip_id
JOIN
    destinations d ON t.destination_id = d.destination_id
WHERE
    i.severity IN ('high', 'medium', 'low')
GROUP BY
    d.name, i.severity
"""
```
```{python}
df_incidents_long = pd.read_sql(query_incidents_graph, engine)
```

```{python}
df_incidents_wide = df_incidents_long.pivot_table(
    index='kierunek', 
    columns='severity', 
    values='liczba_incydentow',
    fill_value=0
)
color_map = {'high': '#d9534f', 'medium': '#f0ad4e', 'low': '#5cb85c'}
desired_order = ['low', 'medium', 'high']
ordered_columns = [col for col in desired_order if col in df_incidents_wide.columns]
df_incidents_wide = df_incidents_wide[ordered_columns]
```

```{python}
df_incidents_wide.plot(
    kind='bar', 
    stacked=True, 
    color=color_map,
    figsize=(14, 8)
)
plt.title('Liczba incydentów według destynacji', fontsize=16)
plt.xlabel('Destynacja', fontsize=12)
plt.ylabel('Łączna liczba incydentów', fontsize=12)
plt.xticks(rotation=45, ha='right')
plt.legend(title='Poziom zagrożenia')
plt.tight_layout()
plt.show()
```

```{python}
query_weighted_risk = """
WITH trips_per_destination AS (
    SELECT destination_id, COUNT(trip_id) AS total_trips
    FROM trips
    GROUP BY destination_id
),
weighted_incidents AS (
    SELECT 
        t.destination_id,
        SUM(
            CASE 
                WHEN i.severity = 'High' THEN 10
                WHEN i.severity = 'Medium' THEN 3
                WHEN i.severity = 'Low' THEN 1
                ELSE 0 
            END
        ) AS risk_score
    FROM incidents i
    JOIN trips t ON i.trip_id = t.trip_id
    GROUP BY t.destination_id
)
SELECT 
    d.name AS Kierunek,
    COALESCE(tpd.total_trips, 0) AS Liczba_wypraw,
    COALESCE(wi.risk_score, 0) AS Suma_punktow_ryzyka,
    COALESCE(wi.risk_score / tpd.total_trips, 0) AS Wazony_wspolczynnik_ryzyka
FROM 
    destinations d
LEFT JOIN 
    trips_per_destination tpd ON d.destination_id = tpd.destination_id
LEFT JOIN
    weighted_incidents wi ON d.destination_id = wi.destination_id
WHERE
    tpd.total_trips > 0
ORDER BY 
    Wazony_wspolczynnik_ryzyka DESC;
"""
```

```{python}
df_risk = pd.read_sql(query_weighted_risk, engine)
print("--- Ranking Ryzyka Destynacji (ważony) ---")
print(df_risk.to_string())

# Automatyczny wniosek
print("\n--- Wnioski ---")
most_risky = df_risk.iloc[0]
print(f"Najbardziej ryzykowną destynacją według ważonego wskaźnika jest '{most_risky['Kierunek']}' "
      f"z wynikiem {most_risky['Wazony_wspolczynnik_ryzyka']:.2f} pkt na wyprawę.")
```

Wadliwość statków

```{python}
query_spacecraft_incidents = """
SELECT 
    spacecraft.name AS nazwa_statku,
    COUNT(*) AS liczba_usterek
FROM
    incidents
LEFT JOIN
    trips
ON
    incidents.trip_id = trips.trip_id
LEFT JOIN
    spacecraft
ON
    trips.spacecraft_id = spacecraft.spacecraft_id
WHERE incidents.category = 'equipment'
GROUP BY spacecraft.name
ORDER BY liczba_usterek desc

"""
```

```{python}
df_spacecrafts_incidents = pd.read_sql(query_spacecraft_incidents, engine)
print(df_spacecrafts_incidents.to_string())
```

```{python}
query_failure_rate = """
WITH trips_per_spacecraft AS (
    SELECT 
        spacecraft_id, 
        COUNT(trip_id) AS total_trips
    FROM trips
    GROUP BY spacecraft_id
),
equipment_failures AS (
    SELECT 
        t.spacecraft_id, 
        COUNT(i.incident_id) AS total_failures
    FROM incidents i
    JOIN trips t ON i.trip_id = t.trip_id
    WHERE i.category = 'equipment'
    GROUP BY t.spacecraft_id
)
SELECT
    s.name AS nazwa_statku,
    COALESCE(tps.total_trips, 0) AS liczba_wypraw,
    COALESCE(ef.total_failures, 0) AS liczba_usterek,
    CASE
        WHEN tps.total_trips > 0 THEN COALESCE(ef.total_failures, 0) / CAST(tps.total_trips AS FLOAT)
        ELSE 0
    END AS usterki_na_wyprawe
FROM
    spacecraft s
LEFT JOIN
    trips_per_spacecraft tps ON s.spacecraft_id = tps.spacecraft_id
LEFT JOIN
    equipment_failures ef ON s.spacecraft_id = ef.spacecraft_id
ORDER BY
    usterki_na_wyprawe DESC;
"""
```

```{python}
df_failure_rate = pd.read_sql(query_failure_rate, engine)
```

```{python}
print("--- Ranking Niezawodności Statków (Usterki na Wyprawę) ---")
print(df_failure_rate.to_string())
plt.figure(figsize=(12, 6))
sns.barplot(data=df_failure_rate, x='usterki_na_wyprawe', y='nazwa_statku', hue="nazwa_statku", palette='Reds_r')
plt.title('Wskaźnik Usterek Sprzętowych na Wyprawę')
plt.xlabel('Średnia liczba usterek na jedną wyprawę')
plt.ylabel('Statek kosmiczny')
plt.tight_layout()
plt.show()
```

```{python}
# --- Automatyczne Wnioski z Rankingu Niezawodności ---

print("\n--- 🤖 Automatyczne Wnioski z Rankingu Niezawodności ---")

most_failure_prone = df_failure_rate.iloc[0]
active_ships = df_failure_rate[df_failure_rate['liczba_wypraw'] > 0]

if not active_ships.empty:
    most_reliable = active_ships.iloc[-1]

    print("\n\n🔧 Najbardziej podatny na usterki jest statek:")
    print(f"   -> Nazwa: '{most_failure_prone['nazwa_statku']}'")
    print(f"   -> Wskaźnik: {most_failure_prone['usterki_na_wyprawe']:.3f} usterek na każdą wyprawę.")
    print(f"   (Na podstawie {int(most_failure_prone['liczba_usterek'])} usterek w ciągu {int(most_failure_prone['liczba_wypraw'])} wypraw).")

    print("\n🏆 Najbardziej niezawodnym statkiem jest:")
    print(f"   -> Nazwa: '{most_reliable['nazwa_statku']}'")
    print(f"   -> Wskaźnik: {most_reliable['usterki_na_wyprawe']:.3f} usterek na każdą wyprawę.")
    
    if most_reliable['usterki_na_wyprawe'] == 0:
        print(f"   (Statek odbył {int(most_reliable['liczba_wypraw'])} wypraw bez odnotowanej usterki sprzętowej - doskonały wynik!)")
    else:
        print(f"   (Na podstawie {int(most_reliable['liczba_usterek'])} usterek w ciągu {int(most_reliable['liczba_wypraw'])} wypraw).")


```

## Problem czwarty
Pytanie: Czy występowanie incydentów ma wpływ na ocenę wyprawy?

```{python}
query_feedback_incidents = """
SELECT 
    AVG(feedback.rating) AS srednia_ocena,
    t.liczba_wypadkow
FROM
    feedback
LEFT JOIN
    trips
ON
    feedback.trip_id = trips.trip_id
LEFT JOIN
    (SELECT
    incidents.trip_id, 
    COUNT(incidents.incident_id) AS liczba_wypadkow
    FROM incidents
    GROUP BY trip_id) t
ON
    t.trip_id = trips.trip_id
GROUP BY 
    feedback.trip_id
"""
```

```{python}
query_correlation = """
WITH avg_ratings AS (
    SELECT trip_id, AVG(rating) AS avg_rating
    FROM feedback
    GROUP BY trip_id
),
incident_counts AS (
    SELECT trip_id, COUNT(incident_id) AS incident_count
    FROM incidents
    GROUP BY trip_id
)
SELECT 
    t.trip_id,
    ar.avg_rating AS srednia_ocena,
    COALESCE(ic.incident_count, 0) AS liczba_incydentow
FROM 
    trips t
JOIN 
    avg_ratings ar ON t.trip_id = ar.trip_id
LEFT JOIN 
    incident_counts ic ON t.trip_id = ic.trip_id;
"""
```

```{python}
df_correlation = pd.read_sql(query_correlation, engine)
```

```{python}
correlation_coeff = df_correlation['srednia_ocena'].corr(df_correlation['liczba_incydentow'])

print(f"--- 🤖 Analiza korelacji: Ocena vs. Incydenty ---")
print(f"Obliczony współczynnik korelacji: {correlation_coeff:.3f}")

if correlation_coeff < -0.3:
    print("Wniosek: Istnieje zauważalna korelacja ujemna. Wzrost liczby incydentów wiąże się ze spadkiem ocen.")
elif correlation_coeff > 0.3:
     print("Wniosek: Istnieje zauważalna korelacja dodatnia (wynik nieoczekiwany).")
else:
    print("Wniosek: Brak silnej korelacji. Liczba incydentów nie wydaje się mieć dużego wpływu na ocenę.")
print("-------------------------------------------------")
plt.figure(figsize=(10, 6))
sns.regplot(data=df_correlation, x='liczba_incydentow', y='srednia_ocena',
            line_kws={"color": "red", "lw": 2}, scatter_kws={"alpha": 0.6})

plt.title('Zależność średniej oceny od liczby incydentów na wyprawie', fontsize=15)
plt.xlabel('Liczba incydentów podczas wyprawy')
plt.ylabel('Średnia ocena wyprawy')
max_incidents = int(df_correlation['liczba_incydentow'].max())
plt.xticks(range(max_incidents + 1))
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()
```

## Problem piąty
Pytanie: Jakie destynacje i rodzaje wycieczek otrzymują najlepsze oceny?

```{python}
query_dest_ratings = """
SELECT
    d.name AS kierunek,
    AVG(f.rating) AS srednia_ocena,
    COUNT(f.rating) AS liczba_ocen
FROM
    feedback f
JOIN
    trips t ON f.trip_id = t.trip_id
JOIN
    destinations d ON t.destination_id = d.destination_id
WHERE f.rating IS NOT NULL
GROUP BY
    d.name
HAVING
    COUNT(f.rating) > 2
ORDER BY
    srednia_ocena DESC;
"""
```

```{python}
df_dest_ratings = pd.read_sql(query_dest_ratings, engine)
```

```{python}
print("\n--- ⭐ Ranking Ocen Destynacji ---")

best_dest = df_dest_ratings.iloc[0]
worst_dest = df_dest_ratings.iloc[-1]

print(f"\n🥇 Najwyżej oceniana destynacja: '{best_dest['kierunek']}'")
print(f"   -> Średnia ocena: {best_dest['srednia_ocena']:.2f} na podstawie {int(best_dest['liczba_ocen'])} opinii.")

print(f"\n📉 Najniżej oceniana destynacja: '{worst_dest['kierunek']}'")
print(f"   -> Średnia ocena: {worst_dest['srednia_ocena']:.2f} na podstawie {int(worst_dest['liczba_ocen'])} opinii.")

```

```{python}
plt.figure(figsize=(12, 7))
sns.barplot(data=df_dest_ratings, x='srednia_ocena', y='kierunek', palette='coolwarm')
plt.title('Ranking średnich ocen dla poszczególnych destynacji', fontsize=15)
plt.xlabel('Średnia ocena (w skali 1-5)')
plt.ylabel('Destynacja')
plt.xlim(0, 5)
plt.tight_layout()
plt.show()
```

```{python}
query_type_ratings = """
SELECT
    tt.name AS typ_wyprawy,
    AVG(f.rating) AS srednia_ocena,
    COUNT(f.rating) AS liczba_ocen
FROM
    feedback f
JOIN
    trips t ON f.trip_id = t.trip_id
JOIN
    trip_types tt ON t.trip_type_id = tt.trip_type_id
WHERE f.rating IS NOT NULL
GROUP BY
    tt.name
HAVING
    COUNT(f.rating) > 2
ORDER BY
    srednia_ocena DESC;
"""
```

```{python}
df_type_ratings = pd.read_sql(query_type_ratings, engine)
```

```{python}
print("\n--- ⭐ Ranking Ocen Rodzajów Wypraw ---")
best_type = df_type_ratings.iloc[0]
worst_type = df_type_ratings.iloc[-1]

print(f"\n🥇 Najwyżej oceniany typ wyprawy: '{best_type['typ_wyprawy']}'")
print(f"   -> Średnia ocena: {best_type['srednia_ocena']:.2f} na podstawie {int(best_type['liczba_ocen'])} opinii.")

print(f"\n📉 Najniżej oceniany typ wyprawy: '{worst_type['typ_wyprawy']}'")
print(f"   -> Średnia ocena: {worst_type['srednia_ocena']:.2f} na podstawie {int(worst_type['liczba_ocen'])} opinii.")
```

```{python}
plt.figure(figsize=(12, 7))
sns.barplot(data=df_type_ratings, x='srednia_ocena', y='typ_wyprawy', palette='viridis')
plt.title('Ranking średnich ocen dla poszczególnych rodzajów wypraw', fontsize=15)
plt.xlabel('Średnia ocena (w skali 1-5)')
plt.ylabel('Rodzaj wyprawy')
plt.xlim(0, 5)
plt.tight_layout()
plt.show()
```

## Problem szósty
Pytanie: Jaka jest struktura wieku naszych klientów?

```{python}
query_dob = """
SELECT date_of_birth
FROM clients
WHERE date_of_birth IS NOT NULL;
"""
```

```{python}
df_dob = pd.read_sql(query_dob, engine)
```

```{python}
today_real = date.today()
df_dob['age'] = df_dob['date_of_birth'].apply(
    lambda dob: (today_real - dob).days / 365.25
) + 100
df_dob['age'] = df_dob['age'].astype(int)
```

```{python}
print("\n--- 📊 Statystyki Wieku Klientów ---")
print(df_dob['age'].describe().round(2).to_string())
print("\n------------------------------------")

plt.figure(figsize=(12, 7))
sns.histplot(data=df_dob, x='age', bins=20, kde=True, color='dodgerblue')

plt.title('Rozkład wieku klientów', fontsize=16)
plt.xlabel('Wiek (w latach)', fontsize=12)
plt.ylabel('Liczba klientów', fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)

plt.show()
```

## Problem siódmy
Analiza RFM

```{python}
today_real = date.today()
future_analysis_date = today_real.replace(year=today_real.year + 100)
analysis_date = future_analysis_date.strftime('%Y-%m-%d')
```

```{python}
query_rfm = f"""
WITH Monetary AS (
    SELECT
        client_id,
        SUM(amount) AS monetary_value
    FROM transactions
    WHERE 
        status = 'Completed' AND
        transaction_date <= '{analysis_date}'
    GROUP BY client_id
),
RecencyFrequency AS (
    SELECT
        p.client_id,
        MAX(t.departure_datetime) AS last_trip_date,
        COUNT(DISTINCT p.trip_id) AS frequency
    FROM trip_participants p
    JOIN trips t ON p.trip_id = t.trip_id
    WHERE 
        t.departure_datetime <= '{analysis_date}'
    GROUP BY p.client_id
)
SELECT
    c.client_id,
    c.first_name,
    c.last_name,
    DATEDIFF('{analysis_date}', rf.last_trip_date) AS recency_days,
    COALESCE(rf.frequency, 0) AS frequency,
    COALESCE(m.monetary_value, 0) AS monetary
FROM
    clients c
LEFT JOIN
    RecencyFrequency rf ON c.client_id = rf.client_id
LEFT JOIN
    Monetary m ON c.client_id = m.client_id;
"""
```

```{python}
df_rfm = pd.read_sql(query_rfm, engine)
df_rfm['recency_days'].fillna(9999, inplace=True)
```

```{python}
df_rfm['R_score'] = 4 - pd.qcut(df_rfm['recency_days'], q=4, labels=False, duplicates='drop')
df_rfm['F_score'] = pd.qcut(df_rfm['frequency'].rank(method='first'), q=4, labels=False, duplicates='drop') + 1
df_rfm['M_score'] = pd.qcut(df_rfm['monetary'].rank(method='first'), q=4, labels=False, duplicates='drop') + 1

df_rfm = df_rfm.astype({'R_score': 'int64', 'F_score': 'int64', 'M_score': 'int64'})
```

```{python}
def assign_segment(row):
    if row['R_score'] >= 4 and row['F_score'] >= 4: return 'Mistrzowie (Champions)'
    if row['R_score'] >= 3 and row['F_score'] >= 3: return 'Lojalni Klienci'
    if row['R_score'] <= 2 and row['F_score'] >= 3: return 'Ryzykowni (At Risk)'
    if row['R_score'] >= 3 and row['M_score'] >= 4: return 'Wieloryby (Big Spenders)'
    if row['R_score'] == 4 and row['F_score'] == 1: return 'Nowi Klienci'
    if row['R_score'] <= 2 and row['F_score'] <= 2: return 'Hibernujący'
    return 'Pozostali'
```
```{python}
df_rfm['Segment'] = df_rfm.apply(assign_segment, axis=1)
```

```{python}
print(f"--- 📊 Analiza RFM (stan na dzień: {analysis_date}) ---")
print("\nPrzykładowe dane po segmentacji:")
print(df_rfm[['first_name', 'last_name', 'recency_days', 'frequency', 'monetary', 'R_score', 'F_score', 'M_score', 'Segment']].head().to_string())
print("\n" + "="*50 + "\n")

plt.figure(figsize=(12, 8))
segment_counts = df_rfm['Segment'].value_counts()
sns.barplot(x=segment_counts.index, y=segment_counts.values, palette='viridis')
plt.title('Rozkład Klientów w Segmentach RFM', fontsize=16)
plt.xlabel('Segment', fontsize=12)
plt.ylabel('Liczba Klientów', fontsize=12)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()
```

```{python}
print("\n\n" + "="*60)
print("--- Zautomatyzowane Podsumowanie Analizy Segmentacji RFM ---")
print("="*60)

print("\n## Podsumowanie ilościowe segmentów:\n")

segment_counts = df_rfm['Segment'].value_counts()
total_clients = len(df_rfm)

for segment, count in segment_counts.items():
    percentage = (count / total_clients) * 100
    print(f"- {segment}: \t{count} klientów ({percentage:.1f}% wszystkich)")

print("\n\n## Rekomendacje Biznesowe dla Firmy:\n")

recommendations = {
    'Mistrzowie (Champions)': 
        "To Twoi najcenniejsi klienci. Angażuj ich, proś o opinie i recenzje, "
        "zaoferuj programy lojalnościowe i dostęp do ekskluzywnych ofert. "
        "Są ambasadorami Twojej marki.",
        
    'Lojalni Klienci': 
        "Są kręgosłupem Twojej firmy. Podtrzymuj ich zaangażowanie, oferując "
        "nowe produkty (cross-selling), lepsze wersje wypraw (up-selling) "
        "i budując z nimi długotrwałą relację.",

    'Ryzykowni (At Risk)': 
        "KLUCZOWA GRUPA DO REAKTYWACJI! To byli dobrzy klienci, którzy dawno "
        "nic nie kupili. Skontaktuj się z nimi osobiście, zaoferuj spersonalizowaną "
        "zniżkę 'na powrót' i dowiedz się, dlaczego przestali podróżować.",

    'Wieloryby (Big Spenders)':
        "Wydają dużo, ale niekoniecznie często. Upewnij się, że są zadowoleni "
        "z jakości usług. Mogą być podatni na oferty konkurencji. Warto zadbać "
        "o ich satysfakcję.",

    'Nowi Klienci':
        "Pierwsze wrażenie jest kluczowe. Zapewnij im doskonałe doświadczenie "
        "na pokładzie i stwórz spersonalizowaną ścieżkę komunikacji (np. seria maili), "
        "aby zachęcić ich do drugiej podróży i zamienić w lojalnych klientów.",
        
    'Hibernujący':
        "Duża grupa nieaktywnych klientów. Jeśli ich liczba jest znacząca, rozważ "
        "szeroko zakrojoną, ale niskokosztową kampanię 'Tęsknimy za Tobą!' z atrakcyjną "
        "ofertą. Nie inwestuj w nich tyle, co w segment 'Ryzykowni'."
}

for segment in segment_counts.index:
    if segment in recommendations:
        print(f"💡 Segment: {segment}")
        print(f"   Rekomendacja: {recommendations[segment]}\n")

print("="*60)
```