---
title: "Gwiezdne Horyzonty 2125"
subtitle: "Roczna Analiza Strategiczna Space-U"
author: "Zespół Analiz Biznesowych Space-U"
lang: pl-PL
date: "2125-06-13"
date-format: "long"
format:
  html:
    toc: true
    number-sections: false
    code-fold: true
    theme:
      light: flatly
      dark: darkly
page-layout: full
---

# Wstęp
W bezkresie kosmosu, podobnie jak w oceanie danych, kluczem do sukcesu jest precyzyjna nawigacja. Od ponad dekady misją Space-U jest nie tylko otwieranie ludzkości drogi do gwiazd, ale również prowadzenie tej ekspansji w sposób mądry, zrównoważony i rentowny. Rok 2034 był kolejnym kamieniem milowym na naszej orbicie sukcesu – rokiem, w którym umocniliśmy naszą pozycję lidera, wysłaliśmy rekordową liczbę pasażerów ku czerwonym piaskom Marsa i zorzom Jowisza, ale także zmierzyliśmy się z nowymi, nieprzewidzianymi wyzwaniami.

Niniejszy raport jest naszą mapą nawigacyjną po minionym roku. Z kosmiczną precyzją przeanalizowaliśmy zebrane dane, aby odpowiedzieć na fundamentalne pytania. Które trajektorie lotów przynoszą największe zyski? Jak zmienia się profil demograficzny naszych międzyplanetarnych podróżników? Gdzie leżą ukryte ryzyka operacyjne – czy to w pasie asteroid, czy w awaryjności naszych statków? I wreszcie – jak odczucia i oceny naszych klientów korelują z incydentami napotkanymi w drodze na orbitę?

Celem tego dokumentu nie jest jedynie kronikarski zapis przeszłości. To przede wszystkim kompas, który ma wskazać kierunek przyszłych działań. Wnioski tu zawarte stanowią solidny, oparty na twardych danych fundament pod strategiczne decyzje, które wyznaczą kurs Space-U na kolejne lata. Informacje te pozwolą nam nie tylko optymalizować obecne operacje, ale także odkrywać zupełnie nowe konstelacje możliwości rynkowych.

Zapnijcie pasy. Wyruszamy w podróż po danych, która ukształtuje przyszłość międzyplanetarnych podróży.

# Analiza danych

```{python}
#| echo: false
#| include: false
import random
import math
from datetime import date, datetime, timedelta, time
import numpy as np
import pandas as pd
import mysql.connector
import plotly.express as px
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from scipy import stats
from sqlalchemy import create_engine
from urllib.parse import quote_plus
from pandas.tseries.offsets import DateOffset 
import plotly.io as pio
from IPython.display import Markdown
import plotly.graph_objects as go
pio.templates.default = "plotly_white" 
```

```{python}
#| echo: false
#| include: false
host = "giniewicz.it"
user = "team13"
password = "te@mlie"
database = "team13"
safe_password = quote_plus(password)

connection_uri = f"mysql+mysqlconnector://{user}:{safe_password}@{host}/{database}"
engine = create_engine(connection_uri)
```

## Analiza rentowności i popularności wypraw

W tej kluczowej sekcji raportu dokonujemy szczegółowego przeglądu naszego portfolio usług. Naszym celem jest precyzyjne zidentyfikowanie, które rodzaje wypraw stanowią trzon naszej oferty – ciesząc się największym zainteresowaniem klientów – oraz, co najważniejsze, jak popularność ta przekłada się na wyniki finansowe. Zrozumienie rentowności poszczególnych "produktów" jest fundamentem do podejmowania świadomych decyzji o alokacji zasobów, strategii cenowej i przyszłych inwestycjach w rozwój floty oraz nowych tras.

Analiza została przeprowadzona na podstawie pełnych danych operacyjnych i finansowych z czterech lat działalności naszej firmy. Wykorzystaliśmy do tego bezpośrednie zapytanie do naszej centralnej bazy danych, agregując informacje o liczbie lotów, całkowitych kosztach misji oraz skompletowanych transakcjach.

```{python}
query = """
SELECT
    tt.name AS 'Rodzaj wyprawy',
    COUNT(t.trip_id) AS 'Liczba wypraw',
    COALESCE(SUM(ac.total_trip_cost), 0) AS 'Całkowite koszty',
    COALESCE(SUM(ar.total_trip_revenue), 0) AS 'Całkowite przychody',
    (COALESCE(SUM(ar.total_trip_revenue), 0) - COALESCE(SUM(ac.total_trip_cost), 0)) AS 'Zysk'
FROM
    trip_types tt
LEFT JOIN
    trips t ON tt.trip_type_id = t.trip_type_id
LEFT JOIN
    (SELECT trip_id, SUM(cost_amount) AS total_trip_cost FROM costs GROUP BY trip_id) ac 
    ON t.trip_id = ac.trip_id
LEFT JOIN
    (SELECT trip_id, SUM(amount) AS total_trip_revenue FROM transactions WHERE status = 'Completed' GROUP BY trip_id) ar 
    ON t.trip_id = ar.trip_id
GROUP BY
    tt.name
ORDER BY
    `Liczba wypraw` DESC;
"""
```

```{python}
df_profitability = pd.read_sql(query, engine)

display(df_profitability.style.format('{:,.2f} zł', subset=['Całkowite koszty', 'Całkowite przychody', 'Zysk'], decimal=',', thousands=' ')\
                         .format('{}', subset=['Liczba wypraw'])\
                         .set_caption("Popularność i rentowność typów wypraw")\
                         .background_gradient(cmap='RdYlGn', subset=['Zysk']))
```


Poniższa tabela prezentuje kompleksowe zestawienie kluczowych wskaźników dla każdego typu wyprawy

```{python}
#| echo: false
#| include: false
print("\n\n--- Wnioski ---")
print("\nNajpopularniejsze rodzaje wypraw:\n")
top_3_profitability = df_profitability.head(3)

for index, row in top_3_profitability.iterrows():
    print(
        f"{index + 1}. Rodzaj '{row['Rodzaj wyprawy']}': "
        f"{row['Liczba wypraw']} wypraw, "
        f"które przyniosły {row['Całkowite przychody']:.2f} przychodu."
    )

print("\nAnaliza rentowności rodzajów wypraw:\n")
unprofitable_types = df_profitability[df_profitability['Zysk'] < 0]
if unprofitable_types.empty:
    print("Wszystkie rodzaje wypraw są opłacalne i nie przynoszą strat.")
else:
    print("UWAGA! Następujące rodzaje wypraw przynoszą straty:")
    for index, row in unprofitable_types.iterrows():
        print(
            f"- '{row['Rodzaj wyprawy']}': zanotowano stratę w wysokości {-row['Zysk']:.2f}"
        )

print("\n----------------------------------")
```

```{python}
#| echo: false

top_3_profitability = df_profitability.head(3)
wnioski_markdown = """
### Liderzy Popularności
Nasze dane jednoznacznie wskazują na grupę flagowych produktów, które stanowią o sile naszej marki. Poniżej przedstawiamy TOP 3 najchętniej wybierane wyprawy:
<ul>
"""

for _, row in top_3_profitability.iterrows():
    liczba_wypraw_str = f"<b>{row['Liczba wypraw']}</b>"
    przychody_str = f"<b>{row['Całkowite przychody']:,.2f} zł</b>"
    wnioski_markdown += (
        f"<li><b>{row['Rodzaj wyprawy']}</b>: zrealizowano {liczba_wypraw_str} wypraw, "
        f"które przyniosły {przychody_str} przychodu.</li>\n"
    )

wnioski_markdown += "</ul>"

display(Markdown(wnioski_markdown))
```

```{python}
#| echo: false

unprofitable_types = df_profitability[df_profitability['Zysk'] < 0]

rentownosc_markdown = """
### Analiza Rentowności
"""

if unprofitable_types.empty:
    rentownosc_markdown += (
        "<p style='color: #198754;'><b>Doskonałe wieści:</b> W analizowanym okresie wszystkie oferowane przez Space-U rodzaje wypraw "
        "okazały się rentowne. To świadczy o zdrowej strukturze kosztów i dobrze skalibrowanej polityce cenowej w całym naszym portfolio.</p>"
    )
else:
    rentownosc_markdown += (
        "<p style='color: #dc3545;'><b>Uwaga Zarządcza:</b> Zidentyfikowano następujące rodzaje wypraw, które generują straty. "
        "Rekomendujemy przeprowadzenie dogłębnej analizy ich struktury kosztów oraz efektywności operacyjnej:</p>"
        "<ul>"
    )
    for _, row in unprofitable_types.iterrows():
        strata_str = f"<b style='color: #dc3545;'>{-row['Zysk']:,.2f} zł</b>"
        rentownosc_markdown += f"<li><b>{row['Rodzaj wyprawy']}</b>: zanotowano stratę w wysokości {strata_str}.</li>\n"
    rentownosc_markdown += "</ul>"

display(Markdown(rentownosc_markdown))
```

## Analiza Dynamiki Bazy Klientów

Analiza miesięcznej liczby obsłużonych klientów jest jednym z fundamentalnych wskaźników kondycji i tempa rozwoju Space-U. To puls naszej działalności, który pozwala ocenić skuteczność naszych działań marketingowych, atrakcyjność oferty oraz ogólne zainteresowanie podróżami kosmicznymi. W tej sekcji zbadamy, czy w ostatnim roku nasza firma znajdowała się na trajektorii wzrostowej, czy też napotkała na turbulencje.

Aby odpowiedzieć na to pytanie, stworzyliśmy wizualizację przedstawiającą liczbę unikalnych klientów w każdym miesiącu. Zamiast polegać na subiektywnej ocenie, nałożyliśmy na dane linię trendu opartą na regresji liniowej, która w obiektywny sposób wskazuje kierunek, w którym zmierzamy.

```{python}
query_clients_per_month = """
SELECT
    DATE_FORMAT(t.departure_datetime, '%Y-%m') AS miesiac,
    COUNT(tp.client_id) AS liczba_klientow
FROM
    trips t
JOIN
    trip_participants tp ON t.trip_id = tp.trip_id
GROUP BY
    miesiac
ORDER BY
    miesiac ASC;
"""
```
```{python}
df_clients = pd.read_sql(query_clients_per_month, engine)
df_clients['srednia_kroczaca'] = df_clients['liczba_klientow'].rolling(window=3, center=True, min_periods=1).mean()
```

```{python}
#| include: false
#| echo: false
plt.figure(figsize=(14, 7))
sns.barplot(data=df_clients, x='miesiac', y='liczba_klientow', color='steelblue')
plt.title('Miesięczna liczba obsłużonych klientów', fontsize=16)
plt.xlabel('Miesiąc', fontsize=12)
plt.ylabel('Liczba klientów', fontsize=12)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()
```

```{python}
x = np.arange(len(df_clients)) 
y = df_clients['liczba_klientow'] 
slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)
stagnation_threshold = 0.5

if slope > stagnation_threshold:
    wniosek = f"Firma wykazuje wyraźny trend WZROSTOWY."
    szczegoly = f"Średnio, z każdym miesiącem liczba klientów rośnie o {slope:.2f}."
elif slope < -stagnation_threshold:
    wniosek = f"Firma wykazuje wyraźny trend SPADKOWY."
    szczegoly = f"Średnio, z każdym miesiącem liczba klientów maleje o {-slope:.2f}."
else:
    wniosek = "Firma wykazuje STAGNACJĘ."
    szczegoly = f"Brak wyraźnego trendu wzrostowego lub spadkowego (nachylenie linii trendu wynosi {slope:.2f})."
```

Poniższy wykres prezentuje miesięczne dane wraz z wygładzoną linią trendu (średnia krocząca), która pomaga zwizualizować ogólną tendencję.
```{python}
#| echo: false
fig = go.Figure()
fig.add_trace(
    go.Bar(
        x=df_clients['miesiac'],
        y=df_clients['liczba_klientow'],
        name='Liczba klientów w miesiącu',
        marker_color='skyblue',
        opacity=0.7
    )
)
fig.add_trace(
    go.Scatter(
        x=df_clients['miesiac'],
        y=df_clients['srednia_kroczaca'],
        name='Trend (średnia krocząca)',
        mode='lines',
        line=dict(color='crimson', width=3)
    )
)
fig.update_layout(
    title='Miesięczna liczba obsłużonych klientów i linia trendu',
    xaxis_title='Miesiąc',
    yaxis_title='Liczba Klientów',
    legend_title='Legenda',
    xaxis_tickangle=-45,
    bargap=0.2,
    xaxis={'type': 'category'} 
)

fig.show()
```

```{python}
analiza_markdown = f"""
### Ocena Linii Trendu 
<p>Analiza statystyczna oparta na regresji liniowej pozwala nam obiektywnie ocenić kierunek rozwoju firmy. Współczynnik nachylenia linii trendu to matematyczna reprezentacja naszego miesięcznego wzrostu lub spadku.</p>
<p><b>Wniosek: {wniosek}</b></p>
<p>{szczegoly}</p>
"""
display(Markdown(analiza_markdown))
```

## Analiza ryzyka operacyjnego
Zarządzanie ryzykiem w turystyce kosmicznej to nie tylko nasz obowiązek, ale fundament, na którym opiera się zaufanie naszych klientów i partnerów. W tej części raportu dokonujemy dogłębnej analizy dwóch głównych źródeł ryzyka: niebezpieczeństw związanych z celem podróży oraz potencjalnej awaryjności naszych statków kosmicznych. Celem jest identyfikacja "gorących punktów", która pozwoli na wdrożenie działań prewencyjnych i podniesienie standardów bezpieczeństwa.

### Ryzyko związane z destynacja
Każda destynacja w Układzie Słonecznym posiada unikalną charakterystykę i wiąże się z różnym poziomem wyzwań. Poniższy wykres przedstawia liczbę zarejestrowanych incydentów w podziale na lokalizacje oraz stopień ich powagi (niski, średni, wysoki).

```{python}
#| include: false
#| echo: false
query_risky_destinations = """
SELECT 
    destinations.name AS kierunek, 
    COUNT(*) AS liczba_wypadkow
FROM
    incidents
LEFT JOIN
    trips
ON
    incidents.trip_id = trips.trip_id
LEFT JOIN
    destinations
ON
    trips.destination_id = destinations.destination_id
GROUP BY
    kierunek
ORDER BY
    liczba_wypadkow DESC;
"""
```
```{python}
#| include: false
#| echo: false
query_risky_dest2 = """
SELECT
    d.name AS kierunek,
    COALESCE(tpd.total_trips, 0) AS liczba_wypraw,
    COALESCE(ipd.total_incidents, 0) AS liczba_incydentow,
    (COALESCE(ipd.total_incidents, 0) * 100.0 / tpd.total_trips) AS wskaznik_ryzyka_procent
FROM
    destinations d
JOIN
    (
        SELECT destination_id, COUNT(trip_id) AS total_trips
        FROM trips
        GROUP BY destination_id
    ) AS tpd ON d.destination_id = tpd.destination_id
LEFT JOIN
    (
        SELECT t.destination_id, COUNT(i.incident_id) AS total_incidents
        FROM incidents i
        JOIN trips t ON i.trip_id = t.trip_id
        GROUP BY t.destination_id
    ) AS ipd ON d.destination_id = ipd.destination_id
ORDER BY
    wskaznik_ryzyka_procent DESC;
"""
```
```{python}
#| include: false
#| echo: false
df_risky_destinations = pd.read_sql(query_risky_destinations, engine)
print(df_risky_destinations.to_string())
```
```{python}
#| include: false
#| echo: false
df_risky_destinations2 = pd.read_sql(query_risky_dest2, engine)
print(df_risky_destinations2.to_string())
```

```{python}
query_incidents_graph = """
SELECT
    d.name AS kierunek,
    i.severity,
    COUNT(i.incident_id) AS liczba_incydentow
FROM
    incidents i
JOIN
    trips t ON i.trip_id = t.trip_id
JOIN
    destinations d ON t.destination_id = d.destination_id
WHERE
    i.severity IN ('high', 'medium', 'low')
GROUP BY
    d.name, i.severity
"""
```
```{python}
df_incidents_long = pd.read_sql(query_incidents_graph, engine)
```
```{python}
df_total_incidents = df_incidents_long.groupby('kierunek')['liczba_incydentow'].sum().sort_values(ascending=False)
df_incidents_long['kierunek_sorted'] = pd.Categorical(df_incidents_long['kierunek'], categories=df_total_incidents.index, ordered=True)

fig = px.bar(
    df_incidents_long.sort_values('kierunek_sorted'), 
    x='kierunek_sorted', 
    y='liczba_incydentow', 
    color='severity',
    title='Liczba incydentów ze względu na destynację',
    labels={'kierunek_sorted': 'Destynacja', 'liczba_incydentow': 'Łączna liczba incydentów', 'severity': 'Poziom zagrożenia'},
    color_discrete_map={'low': '#5cb85c', 'medium': '#f0ad4e', 'high': '#d9534f'},
    category_orders={'severity': ['low', 'medium', 'high']}
)
fig.show()
```
```{python}
#| include: false
#| echo: false
df_incidents_wide = df_incidents_long.pivot_table(
    index='kierunek', 
    columns='severity', 
    values='liczba_incydentow',
    fill_value=0
)
color_map = {'high': '#d9534f', 'medium': '#f0ad4e', 'low': '#5cb85c'}
desired_order = ['low', 'medium', 'high']
ordered_columns = [col for col in desired_order if col in df_incidents_wide.columns]
df_incidents_wide = df_incidents_wide[ordered_columns]
```

```{python}
#| include: false
#| echo: false
df_incidents_wide.plot(
    kind='bar', 
    stacked=True, 
    color=color_map,
    figsize=(14, 8)
)
plt.title('Liczba incydentów według destynacji', fontsize=16)
plt.xlabel('Destynacja', fontsize=12)
plt.ylabel('Łączna liczba incydentów', fontsize=12)
plt.xticks(rotation=45, ha='right')
plt.legend(title='Poziom zagrożenia')
plt.tight_layout()
plt.show()
```

Sama liczba incydentów może być jednak myląca – popularna destynacja naturalnie odnotuje więcej zdarzeń. Aby uzyskać bardziej obiektywny obraz, stworzyliśmy ważony wskaźnik ryzyka. Przypisuje on punkty za każdy incydent w zależności od jego wagi (10 pkt za "High", 3 za "Medium", 1 za "Low"), a następnie dzieli sumę punktów przez liczbę wypraw do danej lokalizacji. Wynik pokazuje średnie "obciążenie ryzykiem" na jedną wyprawę.

```{python}
query_weighted_risk = """
WITH trips_per_destination AS (
    SELECT destination_id, COUNT(trip_id) AS total_trips
    FROM trips
    GROUP BY destination_id
),
weighted_incidents AS (
    SELECT 
        t.destination_id,
        SUM(
            CASE 
                WHEN i.severity = 'High' THEN 10
                WHEN i.severity = 'Medium' THEN 3
                WHEN i.severity = 'Low' THEN 1
                ELSE 0 
            END
        ) AS risk_score
    FROM incidents i
    JOIN trips t ON i.trip_id = t.trip_id
    GROUP BY t.destination_id
)
SELECT 
    d.name AS Kierunek,
    COALESCE(tpd.total_trips, 0) AS Liczba_wypraw,
    COALESCE(wi.risk_score, 0) AS Suma_punktow_ryzyka,
    COALESCE(wi.risk_score / tpd.total_trips, 0) AS Wazony_wspolczynnik_ryzyka
FROM 
    destinations d
LEFT JOIN 
    trips_per_destination tpd ON d.destination_id = tpd.destination_id
LEFT JOIN
    weighted_incidents wi ON d.destination_id = wi.destination_id
WHERE
    tpd.total_trips > 0
ORDER BY 
    Wazony_wspolczynnik_ryzyka DESC;
"""
```

```{python}
df_risk = pd.read_sql(query_weighted_risk, engine)
display(df_risk.style.format('{:.2f}', subset=['Wazony_wspolczynnik_ryzyka'])\
                 .format('{:,.0f}', subset=['Liczba_wypraw', 'Suma_punktow_ryzyka'])\
                 .background_gradient(cmap='Reds', subset=['Wazony_wspolczynnik_ryzyka'])\
                 .set_caption("Tabela 2: Ranking Ryzyka Destynacji (Wskaźnik ważony)"))
```

```{python}
most_risky = df_risk.iloc[0]
least_risky = df_risk.iloc[-1]

wniosek_markdown = f"""
### Podsumowanie Ryzyka Destynacji
<p>Nasz ważony wskaźnik pozwala na obiektywną ocenę i priorytetyzację działań mitygujących ryzyko.</p>
<ul>
    <li><span style="font-size: 1.5em;"></span> <b>Najwyższe ryzyko:</b> Destynacją o najwyższym wskaźniku ryzyka jest <b>{most_risky['Kierunek']}</b> z wynikiem <b>{most_risky['Wazony_wspolczynnik_ryzyka']:.2f} pkt</b> na wyprawę. Sugeruje to konieczność przeglądu procedur bezpieczeństwa dla tej trasy.</li>
    <li><span style="font-size: 1.5em;"></span> <b>Najniższe ryzyko:</b> Najbezpieczniejszą z naszych popularnych destynacji okazał/a się <b>{least_risky['Kierunek']}</b> ({least_risky['Wazony_wspolczynnik_ryzyka']:.2f} pkt/wyprawę). Praktyki stosowane na tej trasie mogą stanowić wzór dla innych.</li>
</ul>
"""
display(Markdown(wniosek_markdown))
```

### Ryzyko związane ze sprzętem
Nawet najbezpieczniejsza trasa staje się ryzykowna, jeśli statek kosmiczny jest zawodny. W tej części analizujemy dane dotyczące awarii sprzętu (category = 'equipment') w naszej flocie, aby zidentyfikować jednostki wymagające szczególnej uwagi serwisowej. Poniższy wykres szereguje statki według wskaźnika "usterki na wyprawę".

```{python}
#| include: false
#| echo: false
query_spacecraft_incidents = """
SELECT 
    spacecraft.name AS nazwa_statku,
    COUNT(*) AS liczba_usterek
FROM
    incidents
LEFT JOIN
    trips
ON
    incidents.trip_id = trips.trip_id
LEFT JOIN
    spacecraft
ON
    trips.spacecraft_id = spacecraft.spacecraft_id
WHERE incidents.category = 'equipment'
GROUP BY spacecraft.name
ORDER BY liczba_usterek desc

"""
```

```{python}
#| include: false
#| echo: false
df_spacecrafts_incidents = pd.read_sql(query_spacecraft_incidents, engine)
print(df_spacecrafts_incidents.to_string())
```

```{python}
query_failure_rate = """
WITH trips_per_spacecraft AS (
    SELECT 
        spacecraft_id, 
        COUNT(trip_id) AS total_trips
    FROM trips
    GROUP BY spacecraft_id
),
equipment_failures AS (
    SELECT 
        t.spacecraft_id, 
        COUNT(i.incident_id) AS total_failures
    FROM incidents i
    JOIN trips t ON i.trip_id = t.trip_id
    WHERE i.category = 'equipment'
    GROUP BY t.spacecraft_id
)
SELECT
    s.name AS nazwa_statku,
    COALESCE(tps.total_trips, 0) AS liczba_wypraw,
    COALESCE(ef.total_failures, 0) AS liczba_usterek,
    CASE
        WHEN tps.total_trips > 0 THEN COALESCE(ef.total_failures, 0) / CAST(tps.total_trips AS FLOAT)
        ELSE 0
    END AS usterki_na_wyprawe
FROM
    spacecraft s
LEFT JOIN
    trips_per_spacecraft tps ON s.spacecraft_id = tps.spacecraft_id
LEFT JOIN
    equipment_failures ef ON s.spacecraft_id = ef.spacecraft_id
ORDER BY
    usterki_na_wyprawe DESC;
"""
```

```{python}
df_failure_rate = pd.read_sql(query_failure_rate, engine)
```

```{python}
df_plot = df_failure_rate.sort_values('usterki_na_wyprawe', ascending=True).copy()
df_plot['Status'] = np.where(df_plot['usterki_na_wyprawe'] > 0, 'Wystąpiły usterki', 'Brak usterek')

fig = px.bar(
    df_plot,
    y='nazwa_statku',
    x='usterki_na_wyprawe',
    orientation='h',
    title='Usterki sprzętowe naszej floty',
    labels={'nazwa_statku': 'Statek kosmiczny', 'usterki_na_wyprawe': 'Średnia liczba usterek na wyprawę'},
    color='Status',
    color_discrete_map={
        'Wystąpiły usterki': '#e74c3c',
        'Brak usterek': '#dfe6e9'
    },
    height=600
)

fig.update_traces(
    texttemplate='%{x:.3f}',
    textposition='outside'
)

max_value = df_plot['usterki_na_wyprawe'].max()
fig.update_xaxes(range=[0, max_value * 1.15])

fig.update_layout(
    showlegend=False,
    plot_bgcolor='white',
    xaxis_gridcolor='#ecf0f1'
)
fig.show()
```

```{python}
#| include: false
#| echo: false
print("--- Ranking Niezawodności Statków (Usterki na Wyprawę) ---")
print(df_failure_rate.to_string())
plt.figure(figsize=(12, 6))
sns.barplot(data=df_failure_rate, x='usterki_na_wyprawe', y='nazwa_statku', hue="nazwa_statku", palette='Reds_r')
plt.title('Wskaźnik Usterek Sprzętowych na Wyprawę')
plt.xlabel('Średnia liczba usterek na jedną wyprawę')
plt.ylabel('Statek kosmiczny')
plt.tight_layout()
plt.show()
```


```{python}
most_failure_prone = df_failure_rate.iloc[0]
zero_failure_ships = df_failure_rate[df_failure_rate['usterki_na_wyprawe'] == 0]
count_zero_failure = len(zero_failure_ships)

wniosek_markdown = """
### Ocena Niezawodności Floty
<p>Analiza wskaźnika usterek pozwala na precyzyjne planowanie przeglądów serwisowych i alokację budżetu na utrzymanie floty.</p>
<ul>
"""

liczba_usterek_prone = int(most_failure_prone['liczba_usterek'])
liczba_wypraw_prone = int(most_failure_prone['liczba_wypraw'])

wniosek_markdown += f"""
<li><b>Wymaga uwagi:</b> Najbardziej podatny na usterki sprzętowe jest statek <b>{most_failure_prone['nazwa_statku']}</b>. 
Odnotowuje on średnio <b>{most_failure_prone['usterki_na_wyprawe']:.3f} usterki</b> na każdą odbytą wyprawę. <br>
<small style="color: #6c757d;"><i>(Na podstawie {liczba_usterek_prone} usterek w ciągu {liczba_wypraw_prone} wypraw)</i></small>
</li>
"""

workhorse_champion = zero_failure_ships.sort_values('liczba_wypraw', ascending=False).iloc[0]
liczba_wypraw_champion = int(workhorse_champion['liczba_wypraw'])

wniosek_markdown += f"""
<li><b>Wzór niezawodności:</b> Aż <b>{count_zero_failure} jednostek</b> w naszej flocie zakończyło wszystkie misje w analizowanym okresie bez żadnej usterki sprzętowej.
Na szczególne wyróżnienie zasługuje <b>{workhorse_champion['nazwa_statku']}</b>, który jest najczęściej eksploatowaną jednostką w tej grupie.<br>
<small style="color: #6c757d;"><i>(Wykonał bezawaryjnie aż {liczba_wypraw_champion} misji)</i></small>
</li>
"""
wniosek_markdown += "</ul>"

display(Markdown(wniosek_markdown))
```

## Wpływ incydentów na satysfakcję klienta

W tej części analizy łączymy "twarde" dane operacyjne z "miękkimi" danymi dotyczącymi odczuć naszych pasażerów. Stawiamy fundamentalne pytanie: czy liczba incydentów zarejestrowanych podczas wyprawy ma statystycznie istotny wpływ na jej końcową ocenę?

Intuicja podpowiada, że każda, nawet drobna usterka czy incydent, może negatywnie wpłynąć na postrzeganie całej, skądinąd udanej, wyprawy. Potwierdzenie lub obalenie tej tezy ma kluczowe znaczenie dla zrozumienia, jak krytyczne jest zapewnienie bezproblemowego przebiegu misji nie tylko dla bezpieczeństwa, ale i dla reputacji oraz siły naszej marki.

Poniższy wykres punktowy przedstawia zależność między średnią oceną danej wyprawy a liczbą odnotowanych w jej trakcie incydentów. Czerwona linia trendu wizualizuje ogólną tendencję tej zależności.

```{python}
#| include: false
#| echo: false
query_feedback_incidents = """
SELECT 
    AVG(feedback.rating) AS srednia_ocena,
    t.liczba_wypadkow
FROM
    feedback
LEFT JOIN
    trips
ON
    feedback.trip_id = trips.trip_id
LEFT JOIN
    (SELECT
    incidents.trip_id, 
    COUNT(incidents.incident_id) AS liczba_wypadkow
    FROM incidents
    GROUP BY trip_id) t
ON
    t.trip_id = trips.trip_id
GROUP BY 
    feedback.trip_id
"""
```

```{python}
query_correlation = """
WITH avg_ratings AS (
    SELECT trip_id, AVG(rating) AS avg_rating
    FROM feedback
    GROUP BY trip_id
),
incident_counts AS (
    SELECT trip_id, COUNT(incident_id) AS incident_count
    FROM incidents
    GROUP BY trip_id
)
SELECT 
    t.trip_id,
    ar.avg_rating AS srednia_ocena,
    COALESCE(ic.incident_count, 0) AS liczba_incydentow
FROM 
    trips t
JOIN 
    avg_ratings ar ON t.trip_id = ar.trip_id
LEFT JOIN 
    incident_counts ic ON t.trip_id = ic.trip_id;
"""
```

```{python}
df_correlation = pd.read_sql(query_correlation, engine)
```

```{python}
fig = px.scatter(
    df_correlation,
    x='liczba_incydentow',
    y='srednia_ocena',
    title='Zależność Oceny Wyprawy od Liczby Incydentów',
    labels={
        'liczba_incydentow': 'Liczba incydentów podczas wyprawy',
        'srednia_ocena': 'Średnia ocena wyprawy (1-5)'
    },
    trendline='ols',
    trendline_color_override='#e74c3c'
)

fig.update_layout(
    plot_bgcolor='white',
    xaxis_gridcolor='#ecf0f1',
    yaxis_gridcolor='#ecf0f1'
)
max_incidents = int(df_correlation['liczba_incydentow'].max())
fig.update_xaxes(
    dtick=1,
    range=[-0.5, max_incidents + 0.5]
)
fig.show()
```

```{python}
correlation_coeff = df_correlation['srednia_ocena'].corr(df_correlation['liczba_incydentow'])

# Logika wniosków
if correlation_coeff < -0.5:
    wniosek = "Istnieje silna korelacja ujemna."
    szczegoly = "Wzrost liczby incydentów jest silnie powiązany ze spadkiem średniej oceny wyprawy."
elif correlation_coeff < -0.2:
    wniosek = "Istnieje zauważalna korelacja ujemna."
    szczegoly = "Wzrost liczby incydentów ma tendencję do obniżania średniej oceny wyprawy."
else:
    wniosek = "Brak silnej korelacji."
    szczegoly = "Liczba incydentów nie wydaje się mieć decydującego wpływu na ocenę końcową. Klienci prawdopodobnie biorą pod uwagę inne czynniki, takie jak widoki, jakość obsługi czy profesjonalizm załogi w radzeniu sobie z incydentem."

```

```{python}
analiza_markdown = f"""
### Analiza korelacji
<p>Obliczony współczynnik korelacji Pearsona dla badanych zmiennych wynosi: <b>{correlation_coeff:.3f}</b>.</p>
<p style="font-size: 1.1em;"><b>Wniosek:</b> {wniosek}</p>
<p>{szczegoly}</p>
"""

display(Markdown(analiza_markdown))
```
```{python}
#| include: false
#| echo: false
correlation_coeff = df_correlation['srednia_ocena'].corr(df_correlation['liczba_incydentow'])

print(f"--- 🤖 Analiza korelacji: Ocena vs. Incydenty ---")
print(f"Obliczony współczynnik korelacji: {correlation_coeff:.3f}")

if correlation_coeff < -0.3:
    print("Wniosek: Istnieje zauważalna korelacja ujemna. Wzrost liczby incydentów wiąże się ze spadkiem ocen.")
elif correlation_coeff > 0.3:
     print("Wniosek: Istnieje zauważalna korelacja dodatnia (wynik nieoczekiwany).")
else:
    print("Wniosek: Brak silnej korelacji. Liczba incydentów nie wydaje się mieć dużego wpływu na ocenę.")
print("-------------------------------------------------")
plt.figure(figsize=(10, 6))
sns.regplot(data=df_correlation, x='liczba_incydentow', y='srednia_ocena',
            line_kws={"color": "red", "lw": 2}, scatter_kws={"alpha": 0.6})

plt.title('Zależność średniej oceny od liczby incydentów na wyprawie', fontsize=15)
plt.xlabel('Liczba incydentów podczas wyprawy')
plt.ylabel('Średnia ocena wyprawy')
max_incidents = int(df_correlation['liczba_incydentow'].max())
plt.xticks(range(max_incidents + 1))
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()
```

## Głos klienta - analiza ocen wypraw

Po analizie wskaźników operacyjnych i finansowych, nadszedł czas, aby wsłuchać się w najważniejszy głos w naszym biznesie – głos klienta. Oceny wystawiane po każdej wyprawie są bezcennym źródłem informacji o naszych mocnych i słabych stronach. W tej sekcji zidentyfikujemy, które elementy naszej oferty są najbardziej doceniane, a które wymagają naszej uwagi.

Analiza opiera się na wszystkich zebranych ocenach, z wyłączeniem destynacji i typów wypraw z małą liczbą opinii (poniżej 3), aby zapewnić statystyczną istotność wyników.

### Ranking ocen destynacji

Pierwszym krokiem jest zrozumienie, które lokalizacje w Układzie Słonecznym dostarczają naszym pasażerom najlepszych wrażeń. Poniższy wykres szereguje nasze destynacje od najniżej do najwyżej ocenianych.

```{python}
query_dest_ratings = """
SELECT
    d.name AS kierunek,
    AVG(f.rating) AS srednia_ocena,
    COUNT(f.rating) AS liczba_ocen
FROM
    feedback f
JOIN
    trips t ON f.trip_id = t.trip_id
JOIN
    destinations d ON t.destination_id = d.destination_id
WHERE f.rating IS NOT NULL
GROUP BY
    d.name
HAVING
    COUNT(f.rating) > 2
ORDER BY
    srednia_ocena DESC;
"""
```

```{python}
df_dest_ratings = pd.read_sql(query_dest_ratings, engine)
```

```{python}
fig_dest = px.bar(
    df_dest_ratings,
    x='srednia_ocena',
    y='kierunek',
    orientation='h',
    title='Ranking Średnich Ocen dla Poszczególnych Destynacji',
    labels={'srednia_ocena': 'Średnia ocena (w skali 1-5)', 'kierunek': 'Destynacja'},
    color='srednia_ocena',
    color_continuous_scale='Plasma',
    text='srednia_ocena',
    height=500
)
fig_dest.update_traces(texttemplate='%{text:.2f}', textposition='outside')
fig_dest.update_layout(xaxis=dict(range=[0, 5.2]), plot_bgcolor='white', yaxis={'categoryorder':'total ascending'})
fig_dest.update_coloraxes(showscale=False)
fig_dest.show()
```

```{python}
best_dest = df_dest_ratings.iloc[0]
worst_dest = df_dest_ratings.iloc[1]

wniosek_markdown = f"""
### Podsumowanie ocen destynacji
<p>Analiza ocen pozwala zidentyfikować nasze "perełki" oraz obszary wymagające poprawy doświadczeń klienta.</p>
<ul>
    <li><b>Najwyżej oceniana:</b> Destynacją, która dostarcza naszym klientom najwięcej satysfakcji, jest <b>{best_dest['kierunek']}</b> ze średnią oceną <b>{best_dest['srednia_ocena']:.2f}</b> (na podstawie {int(best_dest['liczba_ocen'])} opinii).</li>
    <li style="margin-top: 15px;"><b>Wymaga uwagi:</b> Najniższe oceny otrzymuje <b>{worst_dest['kierunek']}</b> (średnia <b>{worst_dest['srednia_ocena']:.2f}</b> z {int(worst_dest['liczba_ocen'])} opinii). Rekomendujemy analizę feedbacku z tej trasy w celu identyfikacji przyczyn niższej satysfakcji.</li>
</ul>
"""
display(Markdown(wniosek_markdown))
```

```{python}
#| include: false
#| echo: false

print("\n--- ⭐ Ranking Ocen Destynacji ---")

best_dest = df_dest_ratings.iloc[0]
worst_dest = df_dest_ratings.iloc[-1]

print(f"\n🥇 Najwyżej oceniana destynacja: '{best_dest['kierunek']}'")
print(f"   -> Średnia ocena: {best_dest['srednia_ocena']:.2f} na podstawie {int(best_dest['liczba_ocen'])} opinii.")

print(f"\n📉 Najniżej oceniana destynacja: '{worst_dest['kierunek']}'")
print(f"   -> Średnia ocena: {worst_dest['srednia_ocena']:.2f} na podstawie {int(worst_dest['liczba_ocen'])} opinii.")

```

```{python}
#| include: false
#| echo: false

plt.figure(figsize=(12, 7))
sns.barplot(data=df_dest_ratings, x='srednia_ocena', y='kierunek', palette='coolwarm')
plt.title('Ranking średnich ocen dla poszczególnych destynacji', fontsize=15)
plt.xlabel('Średnia ocena (w skali 1-5)')
plt.ylabel('Destynacja')
plt.xlim(0, 5)
plt.tight_layout()
plt.show()
```

### Ranking ocen rodzajów wypraw

Następnie sprawdzamy, które typy misji – niezależnie od celu podróży – są najlepiej odbierane przez pasażerów. To pozwala nam ocenić, czy nasze "opakowanie" produktu (luksusowe, badawcze, ekstremalne itd.) trafia w gusta klientów.

```{python}
query_type_ratings = """
SELECT
    tt.name AS typ_wyprawy,
    AVG(f.rating) AS srednia_ocena,
    COUNT(f.rating) AS liczba_ocen
FROM
    feedback f
JOIN
    trips t ON f.trip_id = t.trip_id
JOIN
    trip_types tt ON t.trip_type_id = tt.trip_type_id
WHERE f.rating IS NOT NULL
GROUP BY
    tt.name
HAVING
    COUNT(f.rating) > 2
ORDER BY
    srednia_ocena DESC;
"""
```

```{python}
df_type_ratings = pd.read_sql(query_type_ratings, engine)
```
```{python}
fig_type = px.bar(
    df_type_ratings,
    x='srednia_ocena',
    y='typ_wyprawy',
    orientation='h',
    title='Ranking Średnich Ocen dla Rodzajów Wypraw',
    labels={'srednia_ocena': 'Średnia ocena (w skali 1-5)', 'typ_wyprawy': 'Rodzaj wyprawy'},
    color='srednia_ocena',
    color_continuous_scale='Viridis',
    text='srednia_ocena',
    height=500
)
fig_type.update_traces(texttemplate='%{text:.2f}', textposition='outside')
fig_type.update_layout(xaxis=dict(range=[0, 5.2]), plot_bgcolor='white', yaxis={'categoryorder':'total ascending'})
fig_type.update_coloraxes(showscale=False)
fig_type.show()
```

```{python}
best_type = df_type_ratings.iloc[0]
worst_type = df_type_ratings.iloc[-1]

wniosek_markdown_2 = f"""
### Podsumowanie ocen rodzajów wypraw
<ul>
    <li><b>Ulubiony typ wyprawy:</b> Klienci najwyżej oceniają format <b>{best_type['typ_wyprawy']}</b>, przyznając mu średnią ocenę <b>{best_type['srednia_ocena']:.2f}</b> (na podstawie {int(best_type['liczba_ocen'])} opinii). Warto inwestować w promocję tego segmentu.</li>
    <li style="margin-top: 15px;"><b>Do przemyślenia:</b> Największe wyzwanie stanowi format <b>{worst_type['typ_wyprawy']}</b> (średnia <b>{worst_type['srednia_ocena']:.2f}</b> z {int(worst_type['liczba_ocen'])} opinii). Należy zastanowić się, czy oczekiwania klientów wobec tego typu wypraw są w pełni zaspokajane.</li>
</ul>
"""
display(Markdown(wniosek_markdown_2))
```
```{python}
#| include: false
#| echo: false

print("\n--- ⭐ Ranking Ocen Rodzajów Wypraw ---")
best_type = df_type_ratings.iloc[0]
worst_type = df_type_ratings.iloc[-1]

print(f"\n🥇 Najwyżej oceniany typ wyprawy: '{best_type['typ_wyprawy']}'")
print(f"   -> Średnia ocena: {best_type['srednia_ocena']:.2f} na podstawie {int(best_type['liczba_ocen'])} opinii.")

print(f"\n📉 Najniżej oceniany typ wyprawy: '{worst_type['typ_wyprawy']}'")
print(f"   -> Średnia ocena: {worst_type['srednia_ocena']:.2f} na podstawie {int(worst_type['liczba_ocen'])} opinii.")
```

```{python}
#| include: false
#| echo: false

plt.figure(figsize=(12, 7))
sns.barplot(data=df_type_ratings, x='srednia_ocena', y='typ_wyprawy', palette='viridis')
plt.title('Ranking średnich ocen dla poszczególnych rodzajów wypraw', fontsize=15)
plt.xlabel('Średnia ocena (w skali 1-5)')
plt.ylabel('Rodzaj wyprawy')
plt.xlim(0, 5)
plt.tight_layout()
plt.show()
```

## Profil demograficzny klientów - analiza wieku

Zrozumienie, "kim" jest nasz klient, jest równie ważne, jak wiedza, "dokąd" chce podróżować. Wiek jest jednym z fundamentalnych wymiarów demograficznych, który wpływa na preferencje, możliwości finansowe oraz styl komunikacji. Analiza struktury wiekowej naszej bazy klientów pozwala nam zweryfikować, czy nasza oferta trafia do zamierzonej grupy docelowej i gdzie leżą potencjalne, niewykorzystane jeszcze segmenty rynku.

Poniższa analiza opiera się na datach urodzenia wszystkich naszych zarejestrowanych klientów.

```{python}
query_dob = """
SELECT date_of_birth
FROM clients
WHERE date_of_birth IS NOT NULL;
"""
```

```{python}
df_dob = pd.read_sql(query_dob, engine)
```

```{python}
today_real = date.today()
df_dob['age'] = df_dob['date_of_birth'].apply(
    lambda dob: (today_real - dob).days / 365.25
) + 100
df_dob['age'] = df_dob['age'].astype(int)
```

```{python}
fig = px.histogram(
    df_dob,
    x='age',
    nbins=25,
    title='Rozkład Wieku Klientów Space-U',
    labels={'age': 'Wiek klienta (w latach)', 'count': 'Liczba klientów'},
    marginal='rug',
    template='plotly_white',
    histnorm='percent'
)
fig.update_layout(
    yaxis_title='Udział procentowy klientów',
    bargap=0.1,
    plot_bgcolor='white',
    yaxis_ticksuffix='%'
)
fig.update_traces(
    marker_color='#3498db',
    hovertemplate='Wiek: %{x}<br>Udział: %{y:.2f}%'
)
fig.show()
```

```{python}
stats = df_dob['age'].describe()

# Budowanie bloku Markdown
analiza_markdown = f"""
### Kluczowe Statystyki Wieku
<p>Poniższe dane charakteryzują typowego klienta Space-U pod względem wieku.</p>
<ul>
<li><b>Średni wiek:</b> {stats['mean']:.1f} lat</li>
<li><b>Mediana (wiek środkowy):</b> {stats['50%']:.0f} lat</li>
<li><b>Przedział wiekowy:</b> od {stats['min']:.0f} do {stats['max']:.0f} lat</li>
<li><b>Odchylenie standardowe:</b> {stats['std']:.1f} lat</li>
</ul>
<hr style='margin: 15px 0;'>
<p><b>Wnioski biznesowe:</b> Nasza baza klientów jest wyraźnie skoncentrowana wokół osób w wieku <b>od {stats['25%']:.0f} do {stats['75%']:.0f} lat</b> (środkowe 50% klientów), co sugeruje, że nasza oferta najsilniej rezonuje z osobami o ustabilizowanej pozycji zawodowej i finansowej. Niskie odchylenie standardowe potwierdza tę silną koncentrację. Warto rozważyć stworzenie dedykowanych kampanii lub produktów skierowanych do młodszych i starszych grup demograficznych, które są obecnie słabiej reprezentowane.</p>
"""

display(Markdown(analiza_markdown))
```

```{python}
#| include: false
#| echo: false
print("\n--- 📊 Statystyki Wieku Klientów ---")
print(df_dob['age'].describe().round(2).to_string())
print("\n------------------------------------")

plt.figure(figsize=(12, 7))
sns.histplot(data=df_dob, x='age', bins=20, kde=True, color='dodgerblue')

plt.title('Rozkład wieku klientów', fontsize=16)
plt.xlabel('Wiek (w latach)', fontsize=12)
plt.ylabel('Liczba klientów', fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)

plt.show()
```

## Segmentacja klientów metodą RFM
Analiza RFM (Recency, Frequency, Monetary) to sprawdzona i potężna technika marketingowa służąca do segmentacji bazy klientów. Zamiast traktować wszystkich klientów jednakowo, grupujemy ich na podstawie ich zachowań transakcyjnych, odpowiadając na trzy kluczowe pytania:

* **Recency** (Kiedy ostatnio podróżowali?) - Jak niedawno klient skorzystał z naszych usług? Im niższa wartość, tym lepiej.

* **Frequency** (Jak często podróżują?) - Jak często klient do nas wraca? Im wyższa wartość, tym lepiej.

* **Monetary** (Ile wydają?) - Jaka jest łączna wartość wszystkich transakcji danego klienta? Im wyższa wartość, tym lepiej.

Dzięki tej analizie możemy zidentyfikować naszych najcenniejszych klientów ("Mistrzów"), tych, o których musimy zawalczyć ("Ryzykowni"), oraz tych, którzy dopiero rozpoczynają swoją przygodę ze Space-U ("Nowi Klienci"). To fundament pod budowę skutecznych, spersonalizowanych kampanii i strategii utrzymania klienta.

### Rozkład klientów w segmentach RFM

Poniższy wykres przedstawia wielkość poszczególnych segmentów w naszej bazie klientów.
```{python}
today_real = date.today()
future_analysis_date = today_real.replace(year=today_real.year + 100)
analysis_date = future_analysis_date.strftime('%Y-%m-%d')
```

```{python}
query_rfm = f"""
WITH Monetary AS (
    SELECT
        client_id,
        SUM(amount) AS monetary_value
    FROM transactions
    WHERE 
        status = 'Completed' AND
        transaction_date <= '{analysis_date}'
    GROUP BY client_id
),
RecencyFrequency AS (
    SELECT
        p.client_id,
        MAX(t.departure_datetime) AS last_trip_date,
        COUNT(DISTINCT p.trip_id) AS frequency
    FROM trip_participants p
    JOIN trips t ON p.trip_id = t.trip_id
    WHERE 
        t.departure_datetime <= '{analysis_date}'
    GROUP BY p.client_id
)
SELECT
    c.client_id,
    c.first_name,
    c.last_name,
    DATEDIFF('{analysis_date}', rf.last_trip_date) AS recency_days,
    COALESCE(rf.frequency, 0) AS frequency,
    COALESCE(m.monetary_value, 0) AS monetary
FROM
    clients c
LEFT JOIN
    RecencyFrequency rf ON c.client_id = rf.client_id
LEFT JOIN
    Monetary m ON c.client_id = m.client_id;
"""
```

```{python}
df_rfm = pd.read_sql(query_rfm, engine)
df_rfm['recency_days'].fillna(9999, inplace=True)
```

```{python}
df_rfm['R_score'] = 4 - pd.qcut(df_rfm['recency_days'], q=4, labels=False, duplicates='drop')
df_rfm['F_score'] = pd.qcut(df_rfm['frequency'].rank(method='first'), q=4, labels=False, duplicates='drop') + 1
df_rfm['M_score'] = pd.qcut(df_rfm['monetary'].rank(method='first'), q=4, labels=False, duplicates='drop') + 1

df_rfm = df_rfm.astype({'R_score': 'int64', 'F_score': 'int64', 'M_score': 'int64'})
```

```{python}
def assign_segment(row):
    if row['R_score'] >= 4 and row['F_score'] >= 4: return 'Mistrzowie (Champions)'
    if row['R_score'] >= 3 and row['F_score'] >= 3: return 'Lojalni Klienci'
    if row['R_score'] <= 2 and row['F_score'] >= 3: return 'Ryzykowni (At Risk)'
    if row['R_score'] >= 3 and row['M_score'] >= 4: return 'Wieloryby (Big Spenders)'
    if row['R_score'] == 4 and row['F_score'] == 1: return 'Nowi Klienci'
    if row['R_score'] <= 2 and row['F_score'] <= 2: return 'Hibernujący'
    return 'Pozostali'
```
```{python}
df_rfm['Segment'] = df_rfm.apply(assign_segment, axis=1)
segment_counts = df_rfm['Segment'].value_counts()
```
```{python}
fig = px.bar(
    x=segment_counts.index,
    y=segment_counts.values,
    title='Rozkład Klientów w Segmentach RFM',
    labels={'y': 'Liczba Klientów', 'x': 'Segment'},
    text=segment_counts.values,
    color=segment_counts.values,
    color_continuous_scale='Plasma'
)
fig.update_traces(textposition='outside')
fig.update_layout(plot_bgcolor='white', xaxis_tickangle=-45)
fig.update_coloraxes(showscale=False)
fig.show()
```

### Kluczowe segmenty i rekomendacje strategiczne
```{python}

#| include: false
#| echo: false

print(f"--- 📊 Analiza RFM (stan na dzień: {analysis_date}) ---")
print("\nPrzykładowe dane po segmentacji:")
print(df_rfm[['first_name', 'last_name', 'recency_days', 'frequency', 'monetary', 'R_score', 'F_score', 'M_score', 'Segment']].head().to_string())
print("\n" + "="*50 + "\n")

plt.figure(figsize=(12, 8))
segment_counts = df_rfm['Segment'].value_counts()
sns.barplot(x=segment_counts.index, y=segment_counts.values, palette='viridis')
plt.title('Rozkład Klientów w Segmentach RFM', fontsize=16)
plt.xlabel('Segment', fontsize=12)
plt.ylabel('Liczba Klientów', fontsize=12)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()
```

```{python}
segment_counts = df_rfm['Segment'].value_counts()
total_clients = len(df_rfm)

for segment, count in segment_counts.items():
    percentage = (count / total_clients) * 100
    print(f"- {segment}: \t{count} klientów ({percentage:.1f}% wszystkich)")

recommendations = {
    'Mistrzowie (Champions)': 
        "To Twoi najcenniejsi klienci. Angażuj ich, proś o opinie i recenzje, "
        "zaoferuj programy lojalnościowe i dostęp do ekskluzywnych ofert. "
        "Są ambasadorami Twojej marki.",
        
    'Lojalni Klienci': 
        "Są kręgosłupem Twojej firmy. Podtrzymuj ich zaangażowanie, oferując "
        "nowe produkty (cross-selling), lepsze wersje wypraw (up-selling) "
        "i budując z nimi długotrwałą relację.",

    'Ryzykowni (At Risk)': 
        "KLUCZOWA GRUPA DO REAKTYWACJI! To byli dobrzy klienci, którzy dawno "
        "nic nie kupili. Skontaktuj się z nimi osobiście, zaoferuj spersonalizowaną "
        "zniżkę 'na powrót' i dowiedz się, dlaczego przestali podróżować.",

    'Wieloryby (Big Spenders)':
        "Wydają dużo, ale niekoniecznie często. Upewnij się, że są zadowoleni "
        "z jakości usług. Mogą być podatni na oferty konkurencji. Warto zadbać "
        "o ich satysfakcję.",

    'Nowi Klienci':
        "Pierwsze wrażenie jest kluczowe. Zapewnij im doskonałe doświadczenie "
        "na pokładzie i stwórz spersonalizowaną ścieżkę komunikacji (np. seria maili), "
        "aby zachęcić ich do drugiej podróży i zamienić w lojalnych klientów.",
        
    'Hibernujący':
        "Duża grupa nieaktywnych klientów. Jeśli ich liczba jest znacząca, rozważ "
        "szeroko zakrojoną, ale niskokosztową kampanię 'Tęsknimy za Tobą!' z atrakcyjną "
        "ofertą. Nie inwestuj w nich tyle, co w segment 'Ryzykowni'."
}

```

```{python}
rekomendacje_markdown = ""
for segment, count in segment_counts.items():
    if segment in recommendations:
        percentage = (count / total_clients) * 100
        
        rekomendacje_markdown += f"""
##### {segment}
<p>
    {count} klientów ({percentage:.1f}% wszystkich)
</p>
<p>
    <b>Rekomendacja strategiczna:</b> {recommendations[segment]}
</p>
"""

display(Markdown(rekomendacje_markdown))
```