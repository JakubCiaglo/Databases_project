---
title: "Gwiezdne Horyzonty 2125"
subtitle: "Roczna Analiza Strategiczna Space-U"
author: "Zesp√≥≈Ç Analiz Biznesowych Space-U"
lang: pl-PL
date: "2125-06-13"
date-format: "long"
format:
  html:
    toc: true
    number-sections: true
    code-fold: true
    theme:
      light: flatly
      dark: darkly
page-layout: full
---

# Wstƒôp
W bezkresie kosmosu, podobnie jak w oceanie danych, kluczem do sukcesu jest precyzyjna nawigacja. Od ponad dekady misjƒÖ Space-U jest nie tylko otwieranie ludzko≈õci drogi do gwiazd, ale r√≥wnie≈º prowadzenie tej ekspansji w spos√≥b mƒÖdry, zr√≥wnowa≈ºony i rentowny. Rok 2034 by≈Ç kolejnym kamieniem milowym na naszej orbicie sukcesu ‚Äì rokiem, w kt√≥rym umocnili≈õmy naszƒÖ pozycjƒô lidera, wys≈Çali≈õmy rekordowƒÖ liczbƒô pasa≈ºer√≥w ku czerwonym piaskom Marsa i zorzom Jowisza, ale tak≈ºe zmierzyli≈õmy siƒô z nowymi, nieprzewidzianymi wyzwaniami.

Niniejszy raport jest naszƒÖ mapƒÖ nawigacyjnƒÖ po minionym roku. Z kosmicznƒÖ precyzjƒÖ przeanalizowali≈õmy zebrane dane, aby odpowiedzieƒá na fundamentalne pytania. Kt√≥re trajektorie lot√≥w przynoszƒÖ najwiƒôksze zyski? Jak zmienia siƒô profil demograficzny naszych miƒôdzyplanetarnych podr√≥≈ºnik√≥w? Gdzie le≈ºƒÖ ukryte ryzyka operacyjne ‚Äì czy to w pasie asteroid, czy w awaryjno≈õci naszych statk√≥w? I wreszcie ‚Äì jak odczucia i oceny naszych klient√≥w korelujƒÖ z incydentami napotkanymi w drodze na orbitƒô?

Celem tego dokumentu nie jest jedynie kronikarski zapis przesz≈Ço≈õci. To przede wszystkim kompas, kt√≥ry ma wskazaƒá kierunek przysz≈Çych dzia≈Ça≈Ñ. Wnioski tu zawarte stanowiƒÖ solidny, oparty na twardych danych fundament pod strategiczne decyzje, kt√≥re wyznaczƒÖ kurs Space-U na kolejne lata. Informacje te pozwolƒÖ nam nie tylko optymalizowaƒá obecne operacje, ale tak≈ºe odkrywaƒá zupe≈Çnie nowe konstelacje mo≈ºliwo≈õci rynkowych.

Zapnijcie pasy. Wyruszamy w podr√≥≈º po danych, kt√≥ra ukszta≈Çtuje przysz≈Ço≈õƒá miƒôdzyplanetarnych podr√≥≈ºy.

Z analitycznym pozdrowieniem,

Zesp√≥≈Ç Analiz Biznesowych Space-U

# Analiza danych

```{python}
#| echo: false
#| include: false
import random
import math
from datetime import date, datetime, timedelta, time
import numpy as np
import pandas as pd
import mysql.connector
import plotly.express as px
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from scipy import stats
from sqlalchemy import create_engine
from urllib.parse import quote_plus
from pandas.tseries.offsets import DateOffset 
import plotly.io as pio
from IPython.display import Markdown
pio.templates.default = "plotly_white" 
```

```{python}
#| echo: false
#| include: false
host = "giniewicz.it"
user = "team13"
password = "te@mlie"
database = "team13"
safe_password = quote_plus(password)

connection_uri = f"mysql+mysqlconnector://{user}:{safe_password}@{host}/{database}"
engine = create_engine(connection_uri)
```

## Analiza rentowno≈õci i popularno≈õci wypraw

W tej kluczowej sekcji raportu dokonujemy szczeg√≥≈Çowego przeglƒÖdu naszego portfolio us≈Çug. Naszym celem jest precyzyjne zidentyfikowanie, kt√≥re rodzaje wypraw stanowiƒÖ trzon naszej oferty ‚Äì cieszƒÖc siƒô najwiƒôkszym zainteresowaniem klient√≥w ‚Äì oraz, co najwa≈ºniejsze, jak popularno≈õƒá ta przek≈Çada siƒô na wyniki finansowe. Zrozumienie rentowno≈õci poszczeg√≥lnych "produkt√≥w" jest fundamentem do podejmowania ≈õwiadomych decyzji o alokacji zasob√≥w, strategii cenowej i przysz≈Çych inwestycjach w rozw√≥j floty oraz nowych tras.

Analiza zosta≈Ça przeprowadzona na podstawie pe≈Çnych danych operacyjnych i finansowych z czterech lat dzia≈Çalno≈õci naszej firmy. Wykorzystali≈õmy do tego bezpo≈õrednie zapytanie do naszej centralnej bazy danych, agregujƒÖc informacje o liczbie lot√≥w, ca≈Çkowitych kosztach misji oraz skompletowanych transakcjach.

```{python}
query = """
SELECT
    tt.name AS 'Rodzaj wyprawy',
    COUNT(t.trip_id) AS 'Liczba wypraw',
    COALESCE(SUM(ac.total_trip_cost), 0) AS 'Ca≈Çkowite koszty',
    COALESCE(SUM(ar.total_trip_revenue), 0) AS 'Ca≈Çkowite przychody',
    (COALESCE(SUM(ar.total_trip_revenue), 0) - COALESCE(SUM(ac.total_trip_cost), 0)) AS 'Zysk'
FROM
    trip_types tt
LEFT JOIN
    trips t ON tt.trip_type_id = t.trip_type_id
LEFT JOIN
    (SELECT trip_id, SUM(cost_amount) AS total_trip_cost FROM costs GROUP BY trip_id) ac 
    ON t.trip_id = ac.trip_id
LEFT JOIN
    (SELECT trip_id, SUM(amount) AS total_trip_revenue FROM transactions WHERE status = 'Completed' GROUP BY trip_id) ar 
    ON t.trip_id = ar.trip_id
GROUP BY
    tt.name
ORDER BY
    `Liczba wypraw` DESC;
"""
```

Poni≈ºsza tabela prezentuje kompleksowe zestawienie kluczowych wska≈∫nik√≥w dla ka≈ºdego typu wyprawy

```{python}
df_profitability = pd.read_sql(query, engine)

display(df_profitability.style.format('{:,.2f} z≈Ç', subset=['Ca≈Çkowite koszty', 'Ca≈Çkowite przychody', 'Zysk'], decimal=',', thousands=' ')\
                         .format('{}', subset=['Liczba wypraw'])\
                         .set_caption("Popularno≈õƒá i rentowno≈õƒá typ√≥w wypraw")\
                         .background_gradient(cmap='RdYlGn', subset=['Zysk']))
```
```{python}
#| echo: false
#| include: false
print("\n\n--- Wnioski ---")
print("\nNajpopularniejsze rodzaje wypraw:\n")
top_3_profitability = df_profitability.head(3)

for index, row in top_3_profitability.iterrows():
    print(
        f"{index + 1}. Rodzaj '{row['Rodzaj wyprawy']}': "
        f"{row['Liczba wypraw']} wypraw, "
        f"kt√≥re przynios≈Çy {row['Ca≈Çkowite przychody']:.2f} przychodu."
    )

print("\nAnaliza rentowno≈õci rodzaj√≥w wypraw:\n")
unprofitable_types = df_profitability[df_profitability['Zysk'] < 0]
if unprofitable_types.empty:
    print("Wszystkie rodzaje wypraw sƒÖ op≈Çacalne i nie przynoszƒÖ strat.")
else:
    print("UWAGA! NastƒôpujƒÖce rodzaje wypraw przynoszƒÖ straty:")
    for index, row in unprofitable_types.iterrows():
        print(
            f"- '{row['Rodzaj wyprawy']}': zanotowano stratƒô w wysoko≈õci {-row['Zysk']:.2f}"
        )

print("\n----------------------------------")
```

```{python}
#| echo: false
#| label: wyswietl-popularnosc

from IPython.display import Markdown

# --- Obliczenia ---
top_3_profitability = df_profitability.head(3)
wnioski_markdown = """
### Liderzy Popularno≈õci
Nasze dane jednoznacznie wskazujƒÖ na grupƒô flagowych produkt√≥w, kt√≥re stanowiƒÖ o sile naszej marki. Poni≈ºej przedstawiamy TOP 3 najchƒôtniej wybierane wyprawy:
<ul>
"""

for _, row in top_3_profitability.iterrows():
    liczba_wypraw_str = f"<b>{row['Liczba wypraw']}</b>"
    przychody_str = f"<b>{row['Ca≈Çkowite przychody']:,.2f} z≈Ç</b>"
    wnioski_markdown += (
        f"<li><b>{row['Rodzaj wyprawy']}</b>: zrealizowano {liczba_wypraw_str} wypraw, "
        f"kt√≥re przynios≈Çy {przychody_str} przychodu.</li>\n"
    )

wnioski_markdown += "</ul>"

# --- Wy≈õwietlanie ---
display(Markdown(wnioski_markdown))
```

```{python}
#| echo: false
#| label: wyswietl-rentownosc

from IPython.display import Markdown

# --- Obliczenia ---
unprofitable_types = df_profitability[df_profitability['Zysk'] < 0]

rentownosc_markdown = """
### Analiza Rentowno≈õci
"""

if unprofitable_types.empty:
    rentownosc_markdown += (
        "<p style='color: #198754;'><b>Doskona≈Çe wie≈õci:</b> W analizowanym okresie wszystkie oferowane przez Space-U rodzaje wypraw "
        "okaza≈Çy siƒô rentowne. To ≈õwiadczy o zdrowej strukturze koszt√≥w i dobrze skalibrowanej polityce cenowej w ca≈Çym naszym portfolio.</p>"
    )
else:
    rentownosc_markdown += (
        "<p style='color: #dc3545;'><b>Uwaga ZarzƒÖdcza:</b> Zidentyfikowano nastƒôpujƒÖce rodzaje wypraw, kt√≥re generujƒÖ straty. "
        "Rekomendujemy przeprowadzenie dog≈Çƒôbnej analizy ich struktury koszt√≥w oraz efektywno≈õci operacyjnej:</p>"
        "<ul>"
    )
    for _, row in unprofitable_types.iterrows():
        strata_str = f"<b style='color: #dc3545;'>{-row['Zysk']:,.2f} z≈Ç</b>"
        rentownosc_markdown += f"<li><b>{row['Rodzaj wyprawy']}</b>: zanotowano stratƒô w wysoko≈õci {strata_str}.</li>\n"
    rentownosc_markdown += "</ul>"

# --- Wy≈õwietlanie ---
display(Markdown(rentownosc_markdown))
```

## Problem drugi
Pytanie: SporzƒÖd≈∫ wykres liczby obs≈Çu≈ºonych klient√≥w w ka≈ºdym miesiƒÖcu dzia≈Çalno≈õci firmy, czy firma ro≈õnie, czy podupada?

```{python}
query_clients_per_month = """
SELECT
    DATE_FORMAT(t.departure_datetime, '%Y-%m') AS miesiac,
    COUNT(tp.client_id) AS liczba_klientow
FROM
    trips t
JOIN
    trip_participants tp ON t.trip_id = tp.trip_id
GROUP BY
    miesiac
ORDER BY
    miesiac ASC;
"""
```
```{python}
df_clients = pd.read_sql(query_clients_per_month, engine)
```

```{python}
plt.figure(figsize=(14, 7))
sns.barplot(data=df_clients, x='miesiac', y='liczba_klientow', color='steelblue')
plt.title('Miesiƒôczna liczba obs≈Çu≈ºonych klient√≥w', fontsize=16)
plt.xlabel('MiesiƒÖc', fontsize=12)
plt.ylabel('Liczba klient√≥w', fontsize=12)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()
```

```{python}
import plotly.express as px

# Je≈õli 'miesiac' to np. "3025-01", mo≈ºesz zamieniƒá go na string typu "2025-01"
df_clients['miesiac_str'] = df_clients['miesiac'].astype(str)
df_clients = df_clients.sort_values(by='miesiac_str')  # rƒôczne sortowanie

# Poprawki uk≈Çadu
fig = px.bar(df_clients,
             x='miesiac_str',
             y='liczba_klientow',
             text='liczba_klientow',
             title='Miesiƒôczna liczba obs≈Çu≈ºonych klient√≥w',
             labels={'miesiac_str': 'MiesiƒÖc', 'liczba_klientow': 'Liczba Klient√≥w'},
             color_discrete_sequence=['#4c6ef5'])

fig.update_layout(xaxis_tickangle=-45)
fig.update_traces(textposition='outside')
fig.show()


```

```{python}
x = np.arange(len(df_clients)) 
y = df_clients['liczba_klientow'] 
slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)
# Ustalamy pr√≥g "stagnacji", aby uniknƒÖƒá klasyfikowania bardzo ma≈Çych waha≈Ñ
# jako trendu. Np. je≈õli wzrost/spadek jest mniejszy ni≈º 0.5 klienta na miesiƒÖc.
stagnation_threshold = 0.5

if slope > stagnation_threshold:
    wniosek = f"Firma wykazuje wyra≈∫ny trend WZROSTOWY."
    szczegoly = f"≈örednio, z ka≈ºdym miesiƒÖcem liczba klient√≥w ro≈õnie o {slope:.2f}."
elif slope < -stagnation_threshold:
    wniosek = f"Firma wykazuje wyra≈∫ny trend SPADKOWY."
    szczegoly = f"≈örednio, z ka≈ºdym miesiƒÖcem liczba klient√≥w maleje o {-slope:.2f}."
else:
    wniosek = "Firma wykazuje STAGNACJƒò."
    szczegoly = f"Brak wyra≈∫nego trendu wzrostowego lub spadkowego (nachylenie linii trendu wynosi {slope:.2f})."
print("--- Automatyczna Analiza Trendu ---")
print(f"Wsp√≥≈Çczynnik nachylenia linii trendu: {slope:.4f}")
print(f"\nWniosek: {wniosek}")
print(szczegoly)
print("-----------------------------------")
```

## Problem trzeci
Pytanie: Kt√≥re destynacje sƒÖ najbardziej ryzykowne?

```{python}
query_risky_destinations = """
SELECT 
    destinations.name AS kierunek, 
    COUNT(*) AS liczba_wypadkow
FROM
    incidents
LEFT JOIN
    trips
ON
    incidents.trip_id = trips.trip_id
LEFT JOIN
    destinations
ON
    trips.destination_id = destinations.destination_id
GROUP BY
    kierunek
ORDER BY
    liczba_wypadkow DESC;
"""
```
```{python}
query_risky_dest2 = """
SELECT
    d.name AS kierunek,
    COALESCE(tpd.total_trips, 0) AS liczba_wypraw,
    COALESCE(ipd.total_incidents, 0) AS liczba_incydentow,
    (COALESCE(ipd.total_incidents, 0) * 100.0 / tpd.total_trips) AS wskaznik_ryzyka_procent
FROM
    destinations d
JOIN
    -- Pierwsze podzapytanie zdefiniowane bezpo≈õrednio w FROM
    (
        SELECT destination_id, COUNT(trip_id) AS total_trips
        FROM trips
        GROUP BY destination_id
    ) AS tpd ON d.destination_id = tpd.destination_id
LEFT JOIN
    -- Drugie podzapytanie zdefiniowane bezpo≈õrednio w FROM
    (
        SELECT t.destination_id, COUNT(i.incident_id) AS total_incidents
        FROM incidents i
        JOIN trips t ON i.trip_id = t.trip_id
        GROUP BY t.destination_id
    ) AS ipd ON d.destination_id = ipd.destination_id
ORDER BY
    wskaznik_ryzyka_procent DESC;
"""
```
```{python}
df_risky_destinations = pd.read_sql(query_risky_destinations, engine)
```
```{python}
print(df_risky_destinations.to_string())
```
```{python}
df_risky_destinations2 = pd.read_sql(query_risky_dest2, engine)
```
```{python}
print(df_risky_destinations2.to_string())
```

```{python}
query_incidents_graph = """
SELECT
    d.name AS kierunek,
    i.severity,
    COUNT(i.incident_id) AS liczba_incydentow
FROM
    incidents i
JOIN
    trips t ON i.trip_id = t.trip_id
JOIN
    destinations d ON t.destination_id = d.destination_id
WHERE
    i.severity IN ('high', 'medium', 'low')
GROUP BY
    d.name, i.severity
"""
```
```{python}
df_incidents_long = pd.read_sql(query_incidents_graph, engine)
```

```{python}
df_incidents_wide = df_incidents_long.pivot_table(
    index='kierunek', 
    columns='severity', 
    values='liczba_incydentow',
    fill_value=0
)
color_map = {'high': '#d9534f', 'medium': '#f0ad4e', 'low': '#5cb85c'}
desired_order = ['low', 'medium', 'high']
ordered_columns = [col for col in desired_order if col in df_incidents_wide.columns]
df_incidents_wide = df_incidents_wide[ordered_columns]
```

```{python}
df_incidents_wide.plot(
    kind='bar', 
    stacked=True, 
    color=color_map,
    figsize=(14, 8)
)
plt.title('Liczba incydent√≥w wed≈Çug destynacji', fontsize=16)
plt.xlabel('Destynacja', fontsize=12)
plt.ylabel('≈ÅƒÖczna liczba incydent√≥w', fontsize=12)
plt.xticks(rotation=45, ha='right')
plt.legend(title='Poziom zagro≈ºenia')
plt.tight_layout()
plt.show()
```

```{python}
query_weighted_risk = """
WITH trips_per_destination AS (
    SELECT destination_id, COUNT(trip_id) AS total_trips
    FROM trips
    GROUP BY destination_id
),
weighted_incidents AS (
    SELECT 
        t.destination_id,
        SUM(
            CASE 
                WHEN i.severity = 'High' THEN 10
                WHEN i.severity = 'Medium' THEN 3
                WHEN i.severity = 'Low' THEN 1
                ELSE 0 
            END
        ) AS risk_score
    FROM incidents i
    JOIN trips t ON i.trip_id = t.trip_id
    GROUP BY t.destination_id
)
SELECT 
    d.name AS Kierunek,
    COALESCE(tpd.total_trips, 0) AS Liczba_wypraw,
    COALESCE(wi.risk_score, 0) AS Suma_punktow_ryzyka,
    COALESCE(wi.risk_score / tpd.total_trips, 0) AS Wazony_wspolczynnik_ryzyka
FROM 
    destinations d
LEFT JOIN 
    trips_per_destination tpd ON d.destination_id = tpd.destination_id
LEFT JOIN
    weighted_incidents wi ON d.destination_id = wi.destination_id
WHERE
    tpd.total_trips > 0
ORDER BY 
    Wazony_wspolczynnik_ryzyka DESC;
"""
```

```{python}
df_risk = pd.read_sql(query_weighted_risk, engine)
print("--- Ranking Ryzyka Destynacji (wa≈ºony) ---")
print(df_risk.to_string())

# Automatyczny wniosek
print("\n--- Wnioski ---")
most_risky = df_risk.iloc[0]
print(f"Najbardziej ryzykownƒÖ destynacjƒÖ wed≈Çug wa≈ºonego wska≈∫nika jest '{most_risky['Kierunek']}' "
      f"z wynikiem {most_risky['Wazony_wspolczynnik_ryzyka']:.2f} pkt na wyprawƒô.")
```

Wadliwo≈õƒá statk√≥w

```{python}
query_spacecraft_incidents = """
SELECT 
    spacecraft.name AS nazwa_statku,
    COUNT(*) AS liczba_usterek
FROM
    incidents
LEFT JOIN
    trips
ON
    incidents.trip_id = trips.trip_id
LEFT JOIN
    spacecraft
ON
    trips.spacecraft_id = spacecraft.spacecraft_id
WHERE incidents.category = 'equipment'
GROUP BY spacecraft.name
ORDER BY liczba_usterek desc

"""
```

```{python}
df_spacecrafts_incidents = pd.read_sql(query_spacecraft_incidents, engine)
print(df_spacecrafts_incidents.to_string())
```

```{python}
query_failure_rate = """
WITH trips_per_spacecraft AS (
    SELECT 
        spacecraft_id, 
        COUNT(trip_id) AS total_trips
    FROM trips
    GROUP BY spacecraft_id
),
equipment_failures AS (
    SELECT 
        t.spacecraft_id, 
        COUNT(i.incident_id) AS total_failures
    FROM incidents i
    JOIN trips t ON i.trip_id = t.trip_id
    WHERE i.category = 'equipment'
    GROUP BY t.spacecraft_id
)
SELECT
    s.name AS nazwa_statku,
    COALESCE(tps.total_trips, 0) AS liczba_wypraw,
    COALESCE(ef.total_failures, 0) AS liczba_usterek,
    CASE
        WHEN tps.total_trips > 0 THEN COALESCE(ef.total_failures, 0) / CAST(tps.total_trips AS FLOAT)
        ELSE 0
    END AS usterki_na_wyprawe
FROM
    spacecraft s
LEFT JOIN
    trips_per_spacecraft tps ON s.spacecraft_id = tps.spacecraft_id
LEFT JOIN
    equipment_failures ef ON s.spacecraft_id = ef.spacecraft_id
ORDER BY
    usterki_na_wyprawe DESC;
"""
```

```{python}
df_failure_rate = pd.read_sql(query_failure_rate, engine)
```

```{python}
print("--- Ranking Niezawodno≈õci Statk√≥w (Usterki na Wyprawƒô) ---")
print(df_failure_rate.to_string())
plt.figure(figsize=(12, 6))
sns.barplot(data=df_failure_rate, x='usterki_na_wyprawe', y='nazwa_statku', hue="nazwa_statku", palette='Reds_r')
plt.title('Wska≈∫nik Usterek Sprzƒôtowych na Wyprawƒô')
plt.xlabel('≈örednia liczba usterek na jednƒÖ wyprawƒô')
plt.ylabel('Statek kosmiczny')
plt.tight_layout()
plt.show()
```

```{python}
# --- Automatyczne Wnioski z Rankingu Niezawodno≈õci ---

print("\n--- ü§ñ Automatyczne Wnioski z Rankingu Niezawodno≈õci ---")

most_failure_prone = df_failure_rate.iloc[0]
active_ships = df_failure_rate[df_failure_rate['liczba_wypraw'] > 0]

if not active_ships.empty:
    most_reliable = active_ships.iloc[-1]

    print("\n\nüîß Najbardziej podatny na usterki jest statek:")
    print(f"   -> Nazwa: '{most_failure_prone['nazwa_statku']}'")
    print(f"   -> Wska≈∫nik: {most_failure_prone['usterki_na_wyprawe']:.3f} usterek na ka≈ºdƒÖ wyprawƒô.")
    print(f"   (Na podstawie {int(most_failure_prone['liczba_usterek'])} usterek w ciƒÖgu {int(most_failure_prone['liczba_wypraw'])} wypraw).")

    print("\nüèÜ Najbardziej niezawodnym statkiem jest:")
    print(f"   -> Nazwa: '{most_reliable['nazwa_statku']}'")
    print(f"   -> Wska≈∫nik: {most_reliable['usterki_na_wyprawe']:.3f} usterek na ka≈ºdƒÖ wyprawƒô.")
    
    if most_reliable['usterki_na_wyprawe'] == 0:
        print(f"   (Statek odby≈Ç {int(most_reliable['liczba_wypraw'])} wypraw bez odnotowanej usterki sprzƒôtowej - doskona≈Çy wynik!)")
    else:
        print(f"   (Na podstawie {int(most_reliable['liczba_usterek'])} usterek w ciƒÖgu {int(most_reliable['liczba_wypraw'])} wypraw).")


```

## Problem czwarty
Pytanie: Czy wystƒôpowanie incydent√≥w ma wp≈Çyw na ocenƒô wyprawy?

```{python}
query_feedback_incidents = """
SELECT 
    AVG(feedback.rating) AS srednia_ocena,
    t.liczba_wypadkow
FROM
    feedback
LEFT JOIN
    trips
ON
    feedback.trip_id = trips.trip_id
LEFT JOIN
    (SELECT
    incidents.trip_id, 
    COUNT(incidents.incident_id) AS liczba_wypadkow
    FROM incidents
    GROUP BY trip_id) t
ON
    t.trip_id = trips.trip_id
GROUP BY 
    feedback.trip_id
"""
```

```{python}
query_correlation = """
WITH avg_ratings AS (
    SELECT trip_id, AVG(rating) AS avg_rating
    FROM feedback
    GROUP BY trip_id
),
incident_counts AS (
    SELECT trip_id, COUNT(incident_id) AS incident_count
    FROM incidents
    GROUP BY trip_id
)
SELECT 
    t.trip_id,
    ar.avg_rating AS srednia_ocena,
    COALESCE(ic.incident_count, 0) AS liczba_incydentow
FROM 
    trips t
JOIN 
    avg_ratings ar ON t.trip_id = ar.trip_id
LEFT JOIN 
    incident_counts ic ON t.trip_id = ic.trip_id;
"""
```

```{python}
df_correlation = pd.read_sql(query_correlation, engine)
```

```{python}
correlation_coeff = df_correlation['srednia_ocena'].corr(df_correlation['liczba_incydentow'])

print(f"--- ü§ñ Analiza korelacji: Ocena vs. Incydenty ---")
print(f"Obliczony wsp√≥≈Çczynnik korelacji: {correlation_coeff:.3f}")

if correlation_coeff < -0.3:
    print("Wniosek: Istnieje zauwa≈ºalna korelacja ujemna. Wzrost liczby incydent√≥w wiƒÖ≈ºe siƒô ze spadkiem ocen.")
elif correlation_coeff > 0.3:
     print("Wniosek: Istnieje zauwa≈ºalna korelacja dodatnia (wynik nieoczekiwany).")
else:
    print("Wniosek: Brak silnej korelacji. Liczba incydent√≥w nie wydaje siƒô mieƒá du≈ºego wp≈Çywu na ocenƒô.")
print("-------------------------------------------------")
plt.figure(figsize=(10, 6))
sns.regplot(data=df_correlation, x='liczba_incydentow', y='srednia_ocena',
            line_kws={"color": "red", "lw": 2}, scatter_kws={"alpha": 0.6})

plt.title('Zale≈ºno≈õƒá ≈õredniej oceny od liczby incydent√≥w na wyprawie', fontsize=15)
plt.xlabel('Liczba incydent√≥w podczas wyprawy')
plt.ylabel('≈örednia ocena wyprawy')
max_incidents = int(df_correlation['liczba_incydentow'].max())
plt.xticks(range(max_incidents + 1))
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()
```

## Problem piƒÖty
Pytanie: Jakie destynacje i rodzaje wycieczek otrzymujƒÖ najlepsze oceny?

```{python}
query_dest_ratings = """
SELECT
    d.name AS kierunek,
    AVG(f.rating) AS srednia_ocena,
    COUNT(f.rating) AS liczba_ocen
FROM
    feedback f
JOIN
    trips t ON f.trip_id = t.trip_id
JOIN
    destinations d ON t.destination_id = d.destination_id
WHERE f.rating IS NOT NULL
GROUP BY
    d.name
HAVING
    COUNT(f.rating) > 2
ORDER BY
    srednia_ocena DESC;
"""
```

```{python}
df_dest_ratings = pd.read_sql(query_dest_ratings, engine)
```

```{python}
print("\n--- ‚≠ê Ranking Ocen Destynacji ---")

best_dest = df_dest_ratings.iloc[0]
worst_dest = df_dest_ratings.iloc[-1]

print(f"\nü•á Najwy≈ºej oceniana destynacja: '{best_dest['kierunek']}'")
print(f"   -> ≈örednia ocena: {best_dest['srednia_ocena']:.2f} na podstawie {int(best_dest['liczba_ocen'])} opinii.")

print(f"\nüìâ Najni≈ºej oceniana destynacja: '{worst_dest['kierunek']}'")
print(f"   -> ≈örednia ocena: {worst_dest['srednia_ocena']:.2f} na podstawie {int(worst_dest['liczba_ocen'])} opinii.")

```

```{python}
plt.figure(figsize=(12, 7))
sns.barplot(data=df_dest_ratings, x='srednia_ocena', y='kierunek', palette='coolwarm')
plt.title('Ranking ≈õrednich ocen dla poszczeg√≥lnych destynacji', fontsize=15)
plt.xlabel('≈örednia ocena (w skali 1-5)')
plt.ylabel('Destynacja')
plt.xlim(0, 5)
plt.tight_layout()
plt.show()
```

```{python}
query_type_ratings = """
SELECT
    tt.name AS typ_wyprawy,
    AVG(f.rating) AS srednia_ocena,
    COUNT(f.rating) AS liczba_ocen
FROM
    feedback f
JOIN
    trips t ON f.trip_id = t.trip_id
JOIN
    trip_types tt ON t.trip_type_id = tt.trip_type_id
WHERE f.rating IS NOT NULL
GROUP BY
    tt.name
HAVING
    COUNT(f.rating) > 2
ORDER BY
    srednia_ocena DESC;
"""
```

```{python}
df_type_ratings = pd.read_sql(query_type_ratings, engine)
```

```{python}
print("\n--- ‚≠ê Ranking Ocen Rodzaj√≥w Wypraw ---")
best_type = df_type_ratings.iloc[0]
worst_type = df_type_ratings.iloc[-1]

print(f"\nü•á Najwy≈ºej oceniany typ wyprawy: '{best_type['typ_wyprawy']}'")
print(f"   -> ≈örednia ocena: {best_type['srednia_ocena']:.2f} na podstawie {int(best_type['liczba_ocen'])} opinii.")

print(f"\nüìâ Najni≈ºej oceniany typ wyprawy: '{worst_type['typ_wyprawy']}'")
print(f"   -> ≈örednia ocena: {worst_type['srednia_ocena']:.2f} na podstawie {int(worst_type['liczba_ocen'])} opinii.")
```

```{python}
plt.figure(figsize=(12, 7))
sns.barplot(data=df_type_ratings, x='srednia_ocena', y='typ_wyprawy', palette='viridis')
plt.title('Ranking ≈õrednich ocen dla poszczeg√≥lnych rodzaj√≥w wypraw', fontsize=15)
plt.xlabel('≈örednia ocena (w skali 1-5)')
plt.ylabel('Rodzaj wyprawy')
plt.xlim(0, 5)
plt.tight_layout()
plt.show()
```

## Problem sz√≥sty
Pytanie: Jaka jest struktura wieku naszych klient√≥w?

```{python}
query_dob = """
SELECT date_of_birth
FROM clients
WHERE date_of_birth IS NOT NULL;
"""
```

```{python}
df_dob = pd.read_sql(query_dob, engine)
```

```{python}
today_real = date.today()
df_dob['age'] = df_dob['date_of_birth'].apply(
    lambda dob: (today_real - dob).days / 365.25
) + 100
df_dob['age'] = df_dob['age'].astype(int)
```

```{python}
print("\n--- üìä Statystyki Wieku Klient√≥w ---")
print(df_dob['age'].describe().round(2).to_string())
print("\n------------------------------------")

plt.figure(figsize=(12, 7))
sns.histplot(data=df_dob, x='age', bins=20, kde=True, color='dodgerblue')

plt.title('Rozk≈Çad wieku klient√≥w', fontsize=16)
plt.xlabel('Wiek (w latach)', fontsize=12)
plt.ylabel('Liczba klient√≥w', fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)

plt.show()
```

## Problem si√≥dmy
Analiza RFM

```{python}
today_real = date.today()
future_analysis_date = today_real.replace(year=today_real.year + 100)
analysis_date = future_analysis_date.strftime('%Y-%m-%d')
```

```{python}
query_rfm = f"""
WITH Monetary AS (
    SELECT
        client_id,
        SUM(amount) AS monetary_value
    FROM transactions
    WHERE 
        status = 'Completed' AND
        transaction_date <= '{analysis_date}'
    GROUP BY client_id
),
RecencyFrequency AS (
    SELECT
        p.client_id,
        MAX(t.departure_datetime) AS last_trip_date,
        COUNT(DISTINCT p.trip_id) AS frequency
    FROM trip_participants p
    JOIN trips t ON p.trip_id = t.trip_id
    WHERE 
        t.departure_datetime <= '{analysis_date}'
    GROUP BY p.client_id
)
SELECT
    c.client_id,
    c.first_name,
    c.last_name,
    DATEDIFF('{analysis_date}', rf.last_trip_date) AS recency_days,
    COALESCE(rf.frequency, 0) AS frequency,
    COALESCE(m.monetary_value, 0) AS monetary
FROM
    clients c
LEFT JOIN
    RecencyFrequency rf ON c.client_id = rf.client_id
LEFT JOIN
    Monetary m ON c.client_id = m.client_id;
"""
```

```{python}
df_rfm = pd.read_sql(query_rfm, engine)
df_rfm['recency_days'].fillna(9999, inplace=True)
```

```{python}
df_rfm['R_score'] = 4 - pd.qcut(df_rfm['recency_days'], q=4, labels=False, duplicates='drop')
df_rfm['F_score'] = pd.qcut(df_rfm['frequency'].rank(method='first'), q=4, labels=False, duplicates='drop') + 1
df_rfm['M_score'] = pd.qcut(df_rfm['monetary'].rank(method='first'), q=4, labels=False, duplicates='drop') + 1

df_rfm = df_rfm.astype({'R_score': 'int64', 'F_score': 'int64', 'M_score': 'int64'})
```

```{python}
def assign_segment(row):
    if row['R_score'] >= 4 and row['F_score'] >= 4: return 'Mistrzowie (Champions)'
    if row['R_score'] >= 3 and row['F_score'] >= 3: return 'Lojalni Klienci'
    if row['R_score'] <= 2 and row['F_score'] >= 3: return 'Ryzykowni (At Risk)'
    if row['R_score'] >= 3 and row['M_score'] >= 4: return 'Wieloryby (Big Spenders)'
    if row['R_score'] == 4 and row['F_score'] == 1: return 'Nowi Klienci'
    if row['R_score'] <= 2 and row['F_score'] <= 2: return 'HibernujƒÖcy'
    return 'Pozostali'
```
```{python}
df_rfm['Segment'] = df_rfm.apply(assign_segment, axis=1)
```

```{python}
print(f"--- üìä Analiza RFM (stan na dzie≈Ñ: {analysis_date}) ---")
print("\nPrzyk≈Çadowe dane po segmentacji:")
print(df_rfm[['first_name', 'last_name', 'recency_days', 'frequency', 'monetary', 'R_score', 'F_score', 'M_score', 'Segment']].head().to_string())
print("\n" + "="*50 + "\n")

plt.figure(figsize=(12, 8))
segment_counts = df_rfm['Segment'].value_counts()
sns.barplot(x=segment_counts.index, y=segment_counts.values, palette='viridis')
plt.title('Rozk≈Çad Klient√≥w w Segmentach RFM', fontsize=16)
plt.xlabel('Segment', fontsize=12)
plt.ylabel('Liczba Klient√≥w', fontsize=12)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()
```

```{python}
print("\n\n" + "="*60)
print("--- Zautomatyzowane Podsumowanie Analizy Segmentacji RFM ---")
print("="*60)

print("\n## Podsumowanie ilo≈õciowe segment√≥w:\n")

segment_counts = df_rfm['Segment'].value_counts()
total_clients = len(df_rfm)

for segment, count in segment_counts.items():
    percentage = (count / total_clients) * 100
    print(f"- {segment}: \t{count} klient√≥w ({percentage:.1f}% wszystkich)")

print("\n\n## Rekomendacje Biznesowe dla Firmy:\n")

recommendations = {
    'Mistrzowie (Champions)': 
        "To Twoi najcenniejsi klienci. Anga≈ºuj ich, pro≈õ o opinie i recenzje, "
        "zaoferuj programy lojalno≈õciowe i dostƒôp do ekskluzywnych ofert. "
        "SƒÖ ambasadorami Twojej marki.",
        
    'Lojalni Klienci': 
        "SƒÖ krƒôgos≈Çupem Twojej firmy. Podtrzymuj ich zaanga≈ºowanie, oferujƒÖc "
        "nowe produkty (cross-selling), lepsze wersje wypraw (up-selling) "
        "i budujƒÖc z nimi d≈Çugotrwa≈ÇƒÖ relacjƒô.",

    'Ryzykowni (At Risk)': 
        "KLUCZOWA GRUPA DO REAKTYWACJI! To byli dobrzy klienci, kt√≥rzy dawno "
        "nic nie kupili. Skontaktuj siƒô z nimi osobi≈õcie, zaoferuj spersonalizowanƒÖ "
        "zni≈ºkƒô 'na powr√≥t' i dowiedz siƒô, dlaczego przestali podr√≥≈ºowaƒá.",

    'Wieloryby (Big Spenders)':
        "WydajƒÖ du≈ºo, ale niekoniecznie czƒôsto. Upewnij siƒô, ≈ºe sƒÖ zadowoleni "
        "z jako≈õci us≈Çug. MogƒÖ byƒá podatni na oferty konkurencji. Warto zadbaƒá "
        "o ich satysfakcjƒô.",

    'Nowi Klienci':
        "Pierwsze wra≈ºenie jest kluczowe. Zapewnij im doskona≈Çe do≈õwiadczenie "
        "na pok≈Çadzie i stw√≥rz spersonalizowanƒÖ ≈õcie≈ºkƒô komunikacji (np. seria maili), "
        "aby zachƒôciƒá ich do drugiej podr√≥≈ºy i zamieniƒá w lojalnych klient√≥w.",
        
    'HibernujƒÖcy':
        "Du≈ºa grupa nieaktywnych klient√≥w. Je≈õli ich liczba jest znaczƒÖca, rozwa≈º "
        "szeroko zakrojonƒÖ, ale niskokosztowƒÖ kampaniƒô 'Tƒôsknimy za TobƒÖ!' z atrakcyjnƒÖ "
        "ofertƒÖ. Nie inwestuj w nich tyle, co w segment 'Ryzykowni'."
}

for segment in segment_counts.index:
    if segment in recommendations:
        print(f"üí° Segment: {segment}")
        print(f"   Rekomendacja: {recommendations[segment]}\n")

print("="*60)
```