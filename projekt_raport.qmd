---
title: "Projekt z Baz Danych ‚Äì Raport Ko≈Ñcowy"
format:
  html:
    toc: true
    number-sections: true
    code-fold: true
    code-summary: "Rozwi≈Ñ kod"
    theme:
      light: flatly
      dark: darkly
page-layout: full
---

# Autorzy

- Jakub CiƒÖg≈Ço  
- Mateusz ƒÜwiek  
- Marek Dworaczyk  
- Rafa≈Ç G≈Çodek

# Importy
```{python}
import random
import math
from datetime import date, datetime, timedelta, time
import numpy as np
import pandas as pd
import mysql.connector
import plotly.express as px
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as colors
from scipy import stats
from sqlalchemy import create_engine
from urllib.parse import quote_plus
from pandas.tseries.offsets import DateOffset 
```

```{python}

con = mysql.connector.connect(
    host = "giniewicz.it",
    user = "team13",
    password = "te@mlie",
    database = "team13"
)
```

```{python}
host = "giniewicz.it"
user = "team13"
password = "te@mlie"
database = "team13"
safe_password = quote_plus(password)

connection_uri = f"mysql+mysqlconnector://{user}:{safe_password}@{host}/{database}"
engine = create_engine(connection_uri)
```
# Analiza danych

## Problem pierwszy

Pytanie: Znajd≈∫ najpopularniejsze rodzaje wypraw, por√≥wnaj koszta i zyski, czy sƒÖ op≈Çacalne?

```{python}
query = """
SELECT
    tt.name AS 'Rodzaj wyprawy',
    COUNT(t.trip_id) AS 'Liczba wypraw',
    COALESCE(SUM(ac.total_trip_cost), 0) AS 'Ca≈Çkowite koszty',
    COALESCE(SUM(ar.total_trip_revenue), 0) AS 'Ca≈Çkowite przychody',
    (COALESCE(SUM(ar.total_trip_revenue), 0) - COALESCE(SUM(ac.total_trip_cost), 0)) AS 'Zysk'
FROM
    trip_types tt
LEFT JOIN
    trips t ON tt.trip_type_id = t.trip_type_id
LEFT JOIN
    (SELECT trip_id, SUM(cost_amount) AS total_trip_cost FROM costs GROUP BY trip_id) ac 
    ON t.trip_id = ac.trip_id
LEFT JOIN
    (SELECT trip_id, SUM(amount) AS total_trip_revenue FROM transactions WHERE status = 'Completed' GROUP BY trip_id) ar 
    ON t.trip_id = ar.trip_id
GROUP BY
    tt.name
ORDER BY
    `Liczba wypraw` DESC;
"""
```

```{python}
df_profitability = pd.read_sql(query, engine)

print("Analiza popularno≈õci i op≈Çacalno≈õci rodzaj√≥w wypraw:")
print(df_profitability.to_string())
```
```{python}
print("\n\n--- Zautomatyzowana Analiza ---")
print("\n## üèÜ TOP 3 najpopularniejsze rodzaje wypraw:\n")
top_3_profitability = df_profitability.head(3)

for index, row in top_3_profitability.iterrows():
    print(
        f"{index + 1}. Rodzaj '{row['Rodzaj wyprawy']}': "
        f"{row['Liczba wypraw']} wypraw, "
        f"kt√≥re przynios≈Çy {row['Ca≈Çkowite przychody']:.2f} przychodu."
    )

print("\n## üí∞ Analiza rentowno≈õci rodzaj√≥w wypraw:\n")
unprofitable_types = df_profitability[df_profitability['Zysk'] < 0]
if unprofitable_types.empty:
    print("‚úÖ Wszystkie rodzaje wypraw sƒÖ op≈Çacalne i nie przynoszƒÖ strat.")
else:
    print("‚ö†Ô∏è UWAGA! NastƒôpujƒÖce rodzaje wypraw przynoszƒÖ straty:")
    for index, row in unprofitable_types.iterrows():
        print(
            f"- '{row['Rodzaj wyprawy']}': zanotowano stratƒô w wysoko≈õci {-row['Zysk']:.2f}"
        )

print("\n----------------------------------")
```

## Problem drugi
Pytanie: SporzƒÖd≈∫ wykres liczby obs≈Çu≈ºonych klient√≥w w ka≈ºdym miesiƒÖcu dzia≈Çalno≈õci firmy, czy firma ro≈õnie, czy podupada?

```{python}
query_clients_per_month = """
SELECT
    DATE_FORMAT(t.departure_datetime, '%Y-%m') AS miesiac,
    COUNT(tp.client_id) AS liczba_klientow
FROM
    trips t
JOIN
    trip_participants tp ON t.trip_id = tp.trip_id
GROUP BY
    miesiac
ORDER BY
    miesiac ASC;
"""
```
```{python}
df_clients = pd.read_sql(query_clients_per_month, engine)
```

```{python}
plt.figure(figsize=(14, 7))
sns.barplot(data=df_clients, x='miesiac', y='liczba_klientow', color='steelblue')
plt.title('Miesiƒôczna liczba obs≈Çu≈ºonych klient√≥w', fontsize=16)
plt.xlabel('MiesiƒÖc', fontsize=12)
plt.ylabel('Liczba klient√≥w', fontsize=12)
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()
```

```{python}
x = np.arange(len(df_clients)) 
y = df_clients['liczba_klientow'] 
slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)
# Ustalamy pr√≥g "stagnacji", aby uniknƒÖƒá klasyfikowania bardzo ma≈Çych waha≈Ñ
# jako trendu. Np. je≈õli wzrost/spadek jest mniejszy ni≈º 0.5 klienta na miesiƒÖc.
stagnation_threshold = 0.5

if slope > stagnation_threshold:
    wniosek = f"Firma wykazuje wyra≈∫ny trend WZROSTOWY."
    szczegoly = f"≈örednio, z ka≈ºdym miesiƒÖcem liczba klient√≥w ro≈õnie o {slope:.2f}."
elif slope < -stagnation_threshold:
    wniosek = f"Firma wykazuje wyra≈∫ny trend SPADKOWY."
    szczegoly = f"≈örednio, z ka≈ºdym miesiƒÖcem liczba klient√≥w maleje o {-slope:.2f}."
else:
    wniosek = "Firma wykazuje STAGNACJƒò."
    szczegoly = f"Brak wyra≈∫nego trendu wzrostowego lub spadkowego (nachylenie linii trendu wynosi {slope:.2f})."
print("--- Automatyczna Analiza Trendu ---")
print(f"Wsp√≥≈Çczynnik nachylenia linii trendu: {slope:.4f}")
print(f"\nWniosek: {wniosek}")
print(szczegoly)
print("-----------------------------------")
```

## Problem trzeci
Pytanie: Kt√≥re destynacje sƒÖ najbardziej ryzykowne?

```{python}
query_risky_destinations = """
SELECT 
    destinations.name AS kierunek, 
    COUNT(*) AS liczba_wypadkow
FROM
    incidents
LEFT JOIN
    trips
ON
    incidents.trip_id = trips.trip_id
LEFT JOIN
    destinations
ON
    trips.destination_id = destinations.destination_id
GROUP BY
    kierunek
ORDER BY
    liczba_wypadkow DESC;
"""
```
```{python}
query_risky_dest2 = """
SELECT
    d.name AS kierunek,
    COALESCE(tpd.total_trips, 0) AS liczba_wypraw,
    COALESCE(ipd.total_incidents, 0) AS liczba_incydentow,
    (COALESCE(ipd.total_incidents, 0) * 100.0 / tpd.total_trips) AS wskaznik_ryzyka_procent
FROM
    destinations d
JOIN
    -- Pierwsze podzapytanie zdefiniowane bezpo≈õrednio w FROM
    (
        SELECT destination_id, COUNT(trip_id) AS total_trips
        FROM trips
        GROUP BY destination_id
    ) AS tpd ON d.destination_id = tpd.destination_id
LEFT JOIN
    -- Drugie podzapytanie zdefiniowane bezpo≈õrednio w FROM
    (
        SELECT t.destination_id, COUNT(i.incident_id) AS total_incidents
        FROM incidents i
        JOIN trips t ON i.trip_id = t.trip_id
        GROUP BY t.destination_id
    ) AS ipd ON d.destination_id = ipd.destination_id
ORDER BY
    wskaznik_ryzyka_procent DESC;
"""
```
```{python}
df_risky_destinations = pd.read_sql(query_risky_destinations, engine)
```
```{python}
print(df_risky_destinations.to_string())
```
```{python}
df_risky_destinations2 = pd.read_sql(query_risky_dest2, engine)
```
```{python}
print(df_risky_destinations2.to_string())
```

```{python}
query_incidents_graph = """
SELECT
    d.name AS kierunek,
    i.severity,
    COUNT(i.incident_id) AS liczba_incydentow
FROM
    incidents i
JOIN
    trips t ON i.trip_id = t.trip_id
JOIN
    destinations d ON t.destination_id = d.destination_id
WHERE
    i.severity IN ('high', 'medium', 'low')
GROUP BY
    d.name, i.severity
"""
```
```{python}
df_incidents_long = pd.read_sql(query_incidents_graph, engine)
```

```{python}
df_incidents_wide = df_incidents_long.pivot_table(
    index='kierunek', 
    columns='severity', 
    values='liczba_incydentow',
    fill_value=0
)
color_map = {'high': '#d9534f', 'medium': '#f0ad4e', 'low': '#5cb85c'}
desired_order = ['low', 'medium', 'high']
ordered_columns = [col for col in desired_order if col in df_incidents_wide.columns]
df_incidents_wide = df_incidents_wide[ordered_columns]
```

```{python}
df_incidents_wide.plot(
    kind='bar', 
    stacked=True, 
    color=color_map,
    figsize=(14, 8)
)
plt.title('Liczba incydent√≥w wed≈Çug destynacji', fontsize=16)
plt.xlabel('Destynacja', fontsize=12)
plt.ylabel('≈ÅƒÖczna liczba incydent√≥w', fontsize=12)
plt.xticks(rotation=45, ha='right')
plt.legend(title='Poziom zagro≈ºenia')
plt.tight_layout()
plt.show()
```

```{python}
query_weighted_risk = """
WITH trips_per_destination AS (
    SELECT destination_id, COUNT(trip_id) AS total_trips
    FROM trips
    GROUP BY destination_id
),
weighted_incidents AS (
    SELECT 
        t.destination_id,
        SUM(
            CASE 
                WHEN i.severity = 'High' THEN 10
                WHEN i.severity = 'Medium' THEN 3
                WHEN i.severity = 'Low' THEN 1
                ELSE 0 
            END
        ) AS risk_score
    FROM incidents i
    JOIN trips t ON i.trip_id = t.trip_id
    GROUP BY t.destination_id
)
SELECT 
    d.name AS Kierunek,
    COALESCE(tpd.total_trips, 0) AS Liczba_wypraw,
    COALESCE(wi.risk_score, 0) AS Suma_punktow_ryzyka,
    COALESCE(wi.risk_score / tpd.total_trips, 0) AS Wazony_wspolczynnik_ryzyka
FROM 
    destinations d
LEFT JOIN 
    trips_per_destination tpd ON d.destination_id = tpd.destination_id
LEFT JOIN
    weighted_incidents wi ON d.destination_id = wi.destination_id
WHERE
    tpd.total_trips > 0
ORDER BY 
    Wazony_wspolczynnik_ryzyka DESC;
"""
```

```{python}
df_risk = pd.read_sql(query_weighted_risk, engine)
print("--- Ranking Ryzyka Destynacji (wa≈ºony) ---")
print(df_risk.to_string())

# Automatyczny wniosek
print("\n--- Wnioski ---")
most_risky = df_risk.iloc[0]
print(f"Najbardziej ryzykownƒÖ destynacjƒÖ wed≈Çug wa≈ºonego wska≈∫nika jest '{most_risky['Kierunek']}' "
      f"z wynikiem {most_risky['Wazony_wspolczynnik_ryzyka']:.2f} pkt na wyprawƒô.")
```

Wadliwo≈õƒá statk√≥w

```{python}
query_spacecraft_incidents = """
SELECT 
    spacecraft.name AS nazwa_statku,
    COUNT(*) AS liczba_usterek
FROM
    incidents
LEFT JOIN
    trips
ON
    incidents.trip_id = trips.trip_id
LEFT JOIN
    spacecraft
ON
    trips.spacecraft_id = spacecraft.spacecraft_id
WHERE incidents.category = 'equipment'
GROUP BY spacecraft.name
ORDER BY liczba_usterek desc

"""
```

```{python}
df_spacecrafts_incidents = pd.read_sql(query_spacecraft_incidents, engine)
print(df_spacecrafts_incidents.to_string())
```

```{python}
query_failure_rate = """
WITH trips_per_spacecraft AS (
    SELECT 
        spacecraft_id, 
        COUNT(trip_id) AS total_trips
    FROM trips
    GROUP BY spacecraft_id
),
equipment_failures AS (
    SELECT 
        t.spacecraft_id, 
        COUNT(i.incident_id) AS total_failures
    FROM incidents i
    JOIN trips t ON i.trip_id = t.trip_id
    WHERE i.category = 'equipment'
    GROUP BY t.spacecraft_id
)
SELECT
    s.name AS nazwa_statku,
    COALESCE(tps.total_trips, 0) AS liczba_wypraw,
    COALESCE(ef.total_failures, 0) AS liczba_usterek,
    CASE
        WHEN tps.total_trips > 0 THEN COALESCE(ef.total_failures, 0) / CAST(tps.total_trips AS FLOAT)
        ELSE 0
    END AS usterki_na_wyprawe
FROM
    spacecraft s
LEFT JOIN
    trips_per_spacecraft tps ON s.spacecraft_id = tps.spacecraft_id
LEFT JOIN
    equipment_failures ef ON s.spacecraft_id = ef.spacecraft_id
ORDER BY
    usterki_na_wyprawe DESC;
"""
```

```{python}
df_failure_rate = pd.read_sql(query_failure_rate, engine)
```

```{python}
print("--- Ranking Niezawodno≈õci Statk√≥w (Usterki na Wyprawƒô) ---")
print(df_failure_rate.to_string())
plt.figure(figsize=(12, 6))
sns.barplot(data=df_failure_rate, x='usterki_na_wyprawe', y='nazwa_statku', hue="nazwa_statku", palette='Reds_r')
plt.title('Wska≈∫nik Usterek Sprzƒôtowych na Wyprawƒô')
plt.xlabel('≈örednia liczba usterek na jednƒÖ wyprawƒô')
plt.ylabel('Statek kosmiczny')
plt.tight_layout()
plt.show()
```

```{python}
# --- Automatyczne Wnioski z Rankingu Niezawodno≈õci ---

print("\n--- ü§ñ Automatyczne Wnioski z Rankingu Niezawodno≈õci ---")

most_failure_prone = df_failure_rate.iloc[0]
active_ships = df_failure_rate[df_failure_rate['liczba_wypraw'] > 0]

if not active_ships.empty:
    most_reliable = active_ships.iloc[-1]

    print("\n\nüîß Najbardziej podatny na usterki jest statek:")
    print(f"   -> Nazwa: '{most_failure_prone['nazwa_statku']}'")
    print(f"   -> Wska≈∫nik: {most_failure_prone['usterki_na_wyprawe']:.3f} usterek na ka≈ºdƒÖ wyprawƒô.")
    print(f"   (Na podstawie {int(most_failure_prone['liczba_usterek'])} usterek w ciƒÖgu {int(most_failure_prone['liczba_wypraw'])} wypraw).")

    print("\nüèÜ Najbardziej niezawodnym statkiem jest:")
    print(f"   -> Nazwa: '{most_reliable['nazwa_statku']}'")
    print(f"   -> Wska≈∫nik: {most_reliable['usterki_na_wyprawe']:.3f} usterek na ka≈ºdƒÖ wyprawƒô.")
    
    if most_reliable['usterki_na_wyprawe'] == 0:
        print(f"   (Statek odby≈Ç {int(most_reliable['liczba_wypraw'])} wypraw bez odnotowanej usterki sprzƒôtowej - doskona≈Çy wynik!)")
    else:
        print(f"   (Na podstawie {int(most_reliable['liczba_usterek'])} usterek w ciƒÖgu {int(most_reliable['liczba_wypraw'])} wypraw).")


```

## Problem czwarty
Pytanie: Czy wystƒôpowanie incydent√≥w ma wp≈Çyw na ocenƒô wyprawy?

```{python}
query_feedback_incidents = """
SELECT 
    AVG(feedback.rating) AS srednia_ocena,
    t.liczba_wypadkow
FROM
    feedback
LEFT JOIN
    trips
ON
    feedback.trip_id = trips.trip_id
LEFT JOIN
    (SELECT
    incidents.trip_id, 
    COUNT(incidents.incident_id) AS liczba_wypadkow
    FROM incidents
    GROUP BY trip_id) t
ON
    t.trip_id = trips.trip_id
GROUP BY 
    feedback.trip_id
"""
```

```{python}
query_correlation = """
WITH avg_ratings AS (
    SELECT trip_id, AVG(rating) AS avg_rating
    FROM feedback
    GROUP BY trip_id
),
incident_counts AS (
    SELECT trip_id, COUNT(incident_id) AS incident_count
    FROM incidents
    GROUP BY trip_id
)
SELECT 
    t.trip_id,
    ar.avg_rating AS srednia_ocena,
    COALESCE(ic.incident_count, 0) AS liczba_incydentow
FROM 
    trips t
JOIN 
    avg_ratings ar ON t.trip_id = ar.trip_id
LEFT JOIN 
    incident_counts ic ON t.trip_id = ic.trip_id;
"""
```

```{python}
df_correlation = pd.read_sql(query_correlation, engine)
```

```{python}
correlation_coeff = df_correlation['srednia_ocena'].corr(df_correlation['liczba_incydentow'])

print(f"--- ü§ñ Analiza korelacji: Ocena vs. Incydenty ---")
print(f"Obliczony wsp√≥≈Çczynnik korelacji: {correlation_coeff:.3f}")

if correlation_coeff < -0.3:
    print("Wniosek: Istnieje zauwa≈ºalna korelacja ujemna. Wzrost liczby incydent√≥w wiƒÖ≈ºe siƒô ze spadkiem ocen.")
elif correlation_coeff > 0.3:
     print("Wniosek: Istnieje zauwa≈ºalna korelacja dodatnia (wynik nieoczekiwany).")
else:
    print("Wniosek: Brak silnej korelacji. Liczba incydent√≥w nie wydaje siƒô mieƒá du≈ºego wp≈Çywu na ocenƒô.")
print("-------------------------------------------------")
plt.figure(figsize=(10, 6))
sns.regplot(data=df_correlation, x='liczba_incydentow', y='srednia_ocena',
            line_kws={"color": "red", "lw": 2}, scatter_kws={"alpha": 0.6})

plt.title('Zale≈ºno≈õƒá ≈õredniej oceny od liczby incydent√≥w na wyprawie', fontsize=15)
plt.xlabel('Liczba incydent√≥w podczas wyprawy')
plt.ylabel('≈örednia ocena wyprawy')
max_incidents = int(df_correlation['liczba_incydentow'].max())
plt.xticks(range(max_incidents + 1))
plt.grid(True, linestyle='--', alpha=0.6)
plt.show()
```

## Problem piƒÖty
Pytanie: Jakie destynacje i rodzaje wycieczek otrzymujƒÖ najlepsze oceny?

```{python}
query_dest_ratings = """
SELECT
    d.name AS kierunek,
    AVG(f.rating) AS srednia_ocena,
    COUNT(f.rating) AS liczba_ocen
FROM
    feedback f
JOIN
    trips t ON f.trip_id = t.trip_id
JOIN
    destinations d ON t.destination_id = d.destination_id
WHERE f.rating IS NOT NULL
GROUP BY
    d.name
HAVING
    COUNT(f.rating) > 2
ORDER BY
    srednia_ocena DESC;
"""
```

```{python}
df_dest_ratings = pd.read_sql(query_dest_ratings, engine)
```

```{python}
print("\n--- ‚≠ê Ranking Ocen Destynacji ---")

best_dest = df_dest_ratings.iloc[0]
worst_dest = df_dest_ratings.iloc[-1]

print(f"\nü•á Najwy≈ºej oceniana destynacja: '{best_dest['kierunek']}'")
print(f"   -> ≈örednia ocena: {best_dest['srednia_ocena']:.2f} na podstawie {int(best_dest['liczba_ocen'])} opinii.")

print(f"\nüìâ Najni≈ºej oceniana destynacja: '{worst_dest['kierunek']}'")
print(f"   -> ≈örednia ocena: {worst_dest['srednia_ocena']:.2f} na podstawie {int(worst_dest['liczba_ocen'])} opinii.")

```

```{python}
plt.figure(figsize=(12, 7))
sns.barplot(data=df_dest_ratings, x='srednia_ocena', y='kierunek', palette='coolwarm')
plt.title('Ranking ≈õrednich ocen dla poszczeg√≥lnych destynacji', fontsize=15)
plt.xlabel('≈örednia ocena (w skali 1-5)')
plt.ylabel('Destynacja')
plt.xlim(0, 5)
plt.tight_layout()
plt.show()
```

```{python}
query_type_ratings = """
SELECT
    tt.name AS typ_wyprawy,
    AVG(f.rating) AS srednia_ocena,
    COUNT(f.rating) AS liczba_ocen
FROM
    feedback f
JOIN
    trips t ON f.trip_id = t.trip_id
JOIN
    trip_types tt ON t.trip_type_id = tt.trip_type_id
WHERE f.rating IS NOT NULL
GROUP BY
    tt.name
HAVING
    COUNT(f.rating) > 2
ORDER BY
    srednia_ocena DESC;
"""
```

```{python}
df_type_ratings = pd.read_sql(query_type_ratings, engine)
```

```{python}
print("\n--- ‚≠ê Ranking Ocen Rodzaj√≥w Wypraw ---")
best_type = df_type_ratings.iloc[0]
worst_type = df_type_ratings.iloc[-1]

print(f"\nü•á Najwy≈ºej oceniany typ wyprawy: '{best_type['typ_wyprawy']}'")
print(f"   -> ≈örednia ocena: {best_type['srednia_ocena']:.2f} na podstawie {int(best_type['liczba_ocen'])} opinii.")

print(f"\nüìâ Najni≈ºej oceniany typ wyprawy: '{worst_type['typ_wyprawy']}'")
print(f"   -> ≈örednia ocena: {worst_type['srednia_ocena']:.2f} na podstawie {int(worst_type['liczba_ocen'])} opinii.")
```

```{python}
plt.figure(figsize=(12, 7))
sns.barplot(data=df_type_ratings, x='srednia_ocena', y='typ_wyprawy', palette='viridis')
plt.title('Ranking ≈õrednich ocen dla poszczeg√≥lnych rodzaj√≥w wypraw', fontsize=15)
plt.xlabel('≈örednia ocena (w skali 1-5)')
plt.ylabel('Rodzaj wyprawy')
plt.xlim(0, 5)
plt.tight_layout()
plt.show()
```

## Problem sz√≥sty
Pytanie: Jaka jest struktura wieku naszych klient√≥w?

```{python}
query_dob = """
SELECT date_of_birth
FROM clients
WHERE date_of_birth IS NOT NULL;
"""
```

```{python}
df_dob = pd.read_sql(query_dob, engine)
```

```{python}
today_real = date.today()
df_dob['age'] = df_dob['date_of_birth'].apply(
    lambda dob: (today_real - dob).days / 365.25
) + 1000
df_dob['age'] = df_dob['age'].astype(int)
```

```{python}
print("\n--- üìä Statystyki Wieku Klient√≥w ---")
print(df_dob['age'].describe().round(2).to_string())
print("\n------------------------------------")

plt.figure(figsize=(12, 7))
sns.histplot(data=df_dob, x='age', bins=20, kde=True, color='dodgerblue')

plt.title('Rozk≈Çad wieku klient√≥w', fontsize=16)
plt.xlabel('Wiek (w latach)', fontsize=12)
plt.ylabel('Liczba klient√≥w', fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.7)

plt.show()
```

## Problem si√≥dmy
Analiza RFM

```{python}
today_real = date.today()
future_analysis_date = today_real.replace(year=today_real.year + 1000)
```